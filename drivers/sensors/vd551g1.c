/*
 * Copyright (C) 2023-2024 OpenMV, LLC.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Any redistribution, use, or modification in source or binary form
 *    is done solely for personal benefit and not for any commercial
 *    purpose or for monetary gain. For commercial licensing options,
 *    please contact openmv@openmv.io
 *
 * THIS SOFTWARE IS PROVIDED BY THE LICENSOR AND COPYRIGHT OWNER "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR OR COPYRIGHT
 * OWNER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * PixArt VD551G1 driver.
 */
#include "omv_boardconfig.h"
#if (OMV_VD551G1_ENABLE == 1)

#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "omv_i3c.h"
#include "omv_csi.h"
#include "py/mphal.h"

// Register from UM3224
#define VD55G1_SYSTEM_FSM       0x001C
#define VD55G1_CMD_STBY           0x0201
#define UI_STATUS_DEVICE_MODEL_ID  0x0000
#define UI_STATUS_DEVICE_DEVICE_ID  0x0004
#define START_PATCH_ADDRESS 0x2000
#define UI_CMD_BOOT_COMMAND 0x0200
#define UI_SENSOR_SETTINGS_EXT_CLOCK_VALUE 0x0220
#define UI_SENSOR_SETTINGS_MIPI_DATA_RATE_VALUE 0x0224
#define UI_STREAM_STATICS_LINE_LENGTH_VALUE 0x0300
#define UI_STREAM_CTX0_EXPOSURE_MODE_MODE 0x0500
#define UI_STREAM_CTX0_FRAME_LENGTH_VALUE 0x050c
#define UI_STREAM_CTX1_FRAME_LENGTH_VALUE 0x055c
#define UI_STREAM_CTX2_FRAME_LENGTH_VALUE 0x05ac
#define UI_STREAM_CTX3_FRAME_LENGTH_VALUE 0x05af
#define UI_STREAM_CTX0_READOUT_CTRL 0x052e
#define UI_STREAM_CTX0_Y_START 0x0510
#define UI_STREAM_CTX0_Y_HEIGHT 0x0512
#define UI_STREAM_CTX0_X_START 0x0514
#define UI_STREAM_CTX0_X_WIDTH 0x0516
#define EXPOSURE_MANUAL_DIGITAL_GAIN_CH0 0x0504
#define EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A 0x0502
#define EXPOSURE_MANUAL_ANALOG_GAIN 0x0501
#define UI_STREAM_CTX0_GPIO_0_CTRL 0x051d
#define UI_STREAM_CTX0_GPIO_1_CTRL 0x051e
#define UI_STREAM_CTX0_GPIO_2_CTRL 0x051f
#define UI_STREAM_CTX0_GPIO_3_CTRL 0x0520
#define UI_STREAM_CTX0_MASK_FRAME_CTRL 0x0537
#define CONTEXT_NEXT_CONTEXT 0x03e4
#define STREAM_STATICS_FORMAT_CTRL 0x030a
#define STREAM_STATICS_I3C_FRAME_READOUT_CTRL 0x0324
#define STREAM_STATICS_ISL_ENABLE 0x0326
#define STREAM_STATICS_DARKCAL_CTRL 0x032a
#define STREAM_STATICS_CONTEXT_NEXT_CONTEXT 0x0410
#define EXPOSURE_STEP_PROPORTION_A 0x0488
#define EXPOSURE_MANUAL_ANALOG_GAIN 0x0501
#define EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A 0x0502

#define FT_CLK                      (1000000)

#define VD551G1_EXP_OFFSET          (80)
#define VD551G1_EXP_MIN             (80)
#define VD551G1_EXP_DIV             (8)

#define VD551G1_WIDTH_ALIGN         (4)
#define VD551G1_HQVGA_FPS_MAX       (41)
#define VD551G1_QVGA_FPS_MAX        (17)
#define VD551G1_VGA_FPS_MAX         (5)

static const uint8_t patchData1a[25][30] = {
    {
        0xb2, 0x0, 0x0, 0x2, 0x52, 0x0, 0x42, 0x0, 0x56, 0x0, 0x42, 0x0, 0x5c, 0x0, 0x42, 0x0, 0x52, 0x0, 0x42, 0x0, 0x4c, 0x4,
        0x4, 0xfa, 0xc6, 0xf, 0x94, 0xe0, 0x19, 0xe
    },
    {
        0xc9, 0x65, 0x1, 0xc0, 0x28, 0xde, 0xa, 0x42, 0x80, 0xe0, 0x20, 0x42, 0xf8, 0xf3, 0x16, 0xde, 0xc5, 0x8a, 0x19, 0x0,
        0xb8, 0xe0, 0x10, 0x2, 0xc, 0xec, 0x1d, 0xe6, 0x14, 0x2
    },
    {
        0x88, 0x80, 0x4e, 0x4, 0x1, 0x0, 0x10, 0x80, 0x25, 0x2, 0x8, 0x9c, 0x86, 0x2, 0x0, 0x80, 0x8, 0x44, 0x0, 0x98, 0x55,
        0x81, 0x11, 0x85, 0x45, 0x81, 0x11, 0x89, 0x25, 0x81
    },
    {
        0x11, 0x83, 0x2b, 0x0, 0x24, 0xe0, 0x64, 0xc2, 0xb, 0x84, 0xa8, 0x5d, 0x0, 0xef, 0x2b, 0x80, 0x1, 0x83, 0x1b, 0x8c,
        0xd8, 0x49, 0x60, 0xef, 0xb, 0xa1, 0x65, 0x82, 0xb, 0xe
    },
    {
        0x88, 0xf9, 0xa, 0x0, 0x0, 0xe8, 0x9, 0xe, 0xc, 0x80, 0x0, 0x40, 0x4, 0x9c, 0x1, 0x4e, 0xc, 0x80, 0x4c, 0xc, 0x4, 0xf2,
        0x93, 0xdd, 0x4c, 0x4, 0xc, 0xfe, 0x46, 0x4f
    },
    {
        0xfc, 0xe0, 0x6b, 0x80, 0x84, 0x9c, 0x46, 0x41, 0x38, 0xe2, 0xe, 0x9c, 0xb, 0x8c, 0xe8, 0x4a, 0x60, 0xef, 0xb, 0x8c,
        0x8e, 0x9c, 0x28, 0x4f, 0x60, 0xef, 0xb, 0xa1, 0x6a, 0x40
    },
    {
        0x80, 0xe0, 0x85, 0x86, 0x4a, 0x4c, 0x80, 0xe0, 0x25, 0x86, 0x78, 0x57, 0x60, 0xef, 0x96, 0x4d, 0x9c, 0xe1, 0x1, 0x81,
        0x6, 0x98, 0x76, 0xe, 0xe8, 0xe0, 0xb5, 0x81, 0x8, 0x9c
    },
    {
        0x4a, 0x40, 0x88, 0xe0, 0x85, 0x80, 0x8, 0x41, 0x0, 0xe8, 0x35, 0x81, 0x18, 0x41, 0x0, 0xe8, 0x8, 0x98, 0x4a, 0x0, 0xfc,
        0xfb, 0x95, 0xfc, 0x38, 0x59, 0x60, 0xef, 0x2c, 0x0
    },
    {
        0x0, 0xe2, 0x4c, 0xc, 0xc, 0xf6, 0x93, 0xdd, 0x83, 0xc1, 0x13, 0xc5, 0x93, 0xdd, 0xc3, 0xc1, 0x83, 0xc1, 0x13, 0xc3,
        0x93, 0xdd, 0xc3, 0xc1, 0xd, 0xc3, 0x1a, 0x41, 0x8, 0xe4
    },
    {
        0xa, 0x40, 0x84, 0xe1, 0xc, 0x0, 0x0, 0xe2, 0x93, 0xdd, 0x4c, 0x4, 0x4, 0xfa, 0x86, 0x4e, 0xec, 0xe1, 0x8, 0x9e, 0x65,
        0xe, 0x24, 0xf8, 0xe, 0x2, 0x99, 0x7a, 0x0, 0xc0
    },
    {
        0x0, 0x40, 0xf8, 0xf3, 0x6, 0x9e, 0xb, 0x8c, 0x28, 0x57, 0x0, 0xef, 0x25, 0xe, 0x28, 0xf8, 0x2, 0x2, 0xfc, 0xed, 0xf6,
        0x49, 0xfd, 0x6f, 0xe0, 0xff, 0x4, 0xca, 0x14, 0x6
    },
    {
        0xc0, 0xe0, 0xf, 0x88, 0x3f, 0xa0, 0xb, 0x8c, 0x3e, 0xca, 0x28, 0x56, 0x0, 0xef, 0x86, 0x2, 0x84, 0xfe, 0xe, 0x5, 0x9,
        0x7d, 0x0, 0xc0, 0x5, 0x4e, 0x8, 0xf8, 0x18, 0x7d
    },
    {
        0xfc, 0xef, 0x4a, 0x40, 0x80, 0xe0, 0x9, 0xe, 0x4, 0xc0, 0x0, 0x40, 0x40, 0xdc, 0x1, 0x4e, 0x4, 0xc0, 0x4c, 0xc, 0x4,
        0xf2, 0x93, 0xdd, 0xc, 0x0, 0x80, 0xfa, 0x15, 0x0
    },
    {
        0x3c, 0xe0, 0x21, 0x81, 0x31, 0x85, 0x21, 0x42, 0x60, 0xe0, 0x15, 0x0, 0x44, 0xe0, 0x31, 0x42, 0x40, 0xe1, 0x15, 0x0,
        0x34, 0xe0, 0x21, 0x42, 0x20, 0xe0, 0x15, 0x0, 0x34, 0xe0
    },
    {
        0xd6, 0x4, 0x10, 0xe0, 0x23, 0x42, 0x30, 0xe0, 0x15, 0x0, 0x34, 0xe0, 0x86, 0x44, 0x4, 0xe0, 0x23, 0x42, 0x38, 0xe0,
        0x5, 0x0, 0x30, 0xe0, 0xc6, 0x2, 0x8, 0xe0, 0x13, 0x40
    },
    {
        0x10, 0xe3, 0x88, 0x75, 0x40, 0xef, 0x6, 0x40, 0xc, 0xe1, 0x4, 0x80, 0x6, 0x2, 0x94, 0xe0, 0x2b, 0x2, 0xc4, 0xea, 0x3b,
        0x0, 0x78, 0xe2, 0x20, 0x44, 0xfd, 0x73, 0x7, 0xc0
    },
    {
        0x30, 0x46, 0x1, 0x70, 0xf8, 0xc0, 0x3f, 0xa4, 0x33, 0x40, 0x78, 0xe2, 0xa, 0x84, 0xc, 0x8, 0x80, 0xf2, 0x98, 0x1a,
        0x40, 0xff, 0xc3, 0xc1, 0x6, 0x40, 0xc, 0xe1, 0x4, 0x80
    },
    {
        0x1b, 0x0, 0x40, 0xe4, 0x19, 0xc2, 0x13, 0x40, 0x40, 0xe4, 0x1b, 0x0, 0x40, 0xe4, 0x19, 0xc4, 0x13, 0x40, 0x40, 0xe4,
        0x93, 0xdd, 0xc6, 0x43, 0xec, 0xe0, 0x46, 0x41, 0xfc, 0xe0
    },
    {
        0x24, 0x84, 0x4, 0x80, 0x31, 0x81, 0x4a, 0x44, 0x80, 0xe0, 0x86, 0x44, 0xc, 0xe1, 0x9, 0x0, 0x6c, 0xe0, 0xc4, 0x8a,
        0x8e, 0x47, 0xfc, 0x9f, 0x1, 0x42, 0x51, 0x78, 0xc, 0xc0
    },
    {
        0x31, 0x58, 0x90, 0xe0, 0x34, 0x8a, 0x41, 0xbf, 0x6, 0x8, 0x0, 0xc0, 0x41, 0x46, 0xa0, 0xe0, 0x34, 0x8a, 0x51, 0x81,
        0xf6, 0xb, 0x0, 0xc0, 0x51, 0x46, 0xd0, 0xe0, 0x34, 0x8a
    },
    {
        0x1, 0xbf, 0x51, 0x46, 0xe0, 0xe0, 0x44, 0x84, 0xa, 0x48, 0x84, 0xe0, 0x75, 0x86, 0x54, 0xca, 0x49, 0x88, 0x44, 0x6,
        0x88, 0xe1, 0x36, 0x94, 0x4a, 0x46, 0x80, 0xe0, 0x34, 0xca
    },
    {
        0x47, 0xc6, 0x11, 0x8d, 0x41, 0x46, 0xd0, 0xe0, 0x34, 0x88, 0x76, 0x2, 0x0, 0xc0, 0x6, 0x0, 0x0, 0xc0, 0x16, 0x8c, 0x14,
        0x88, 0x1, 0x42, 0xc0, 0xe1, 0x1, 0x42, 0xe0, 0xe1
    },
    {
        0x1, 0x42, 0xf0, 0xe1, 0x93, 0xdd, 0x34, 0xca, 0x41, 0x85, 0x46, 0x8c, 0x34, 0xca, 0x6, 0x48, 0x0, 0xe0, 0x41, 0x46,
        0xd0, 0xe0, 0x34, 0x88, 0x41, 0x83, 0x46, 0x8c, 0x34, 0x88
    },
    {
        0x1, 0x46, 0xc0, 0xe1, 0x1, 0x46, 0xe0, 0xe1, 0x1, 0x46, 0xf0, 0xe1, 0x9, 0x2, 0x20, 0xe0, 0x14, 0xca, 0x3, 0x42, 0x58,
        0xe0, 0x93, 0xdd, 0x0, 0x0, 0x6, 0xa9, 0x0, 0x0
    },
    {
        0x74, 0xff, 0x40, 0x0, 0x8, 0x5, 0x80, 0xe0, 0xa8, 0xc1, 0x40, 0x0, 0x48, 0x37, 0x9c, 0xe0, 0x40, 0x6c, 0x40, 0x0, 0xc8,
        0x26, 0xc8, 0xe0, 0xfc, 0x91, 0x40, 0x0, 0xc8, 0x0
    }

};

static const uint8_t patchData1b[26] = {
    0xb8, 0xe0, 0x30, 0x16, 0x41, 0x0, 0x88, 0x1a, 0x74, 0xe0, 0xb0, 0x7e, 0x40, 0x0, 0x48, 0x1a, 0xc0, 0xe0, 0x0, 0xb9, 0x0,
    0x0, 0xf9, 0xd9, 0x0, 0x0
};

static const uint8_t patchData2a[10][30] = {
    {
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x60, 0x20, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x4, 0x20, 0x0, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x0, 0xc, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x20, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x2, 0x1c, 0x20, 0x0
    },
    {
        0x0, 0x0, 0x0, 0x0, 0xa, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x1c,
        0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c
    },
    {
        0x20, 0x4, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x1c, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0
    },
    {
        0x1, 0x1c, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0, 0x81, 0x1c, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1c, 0x20, 0x28, 0x0, 0x0,
        0x0, 0x0, 0x11, 0x1c, 0x20, 0x8, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x3, 0x1c, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0, 0x23, 0x1c, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0, 0x43, 0x1c, 0x20, 0x8,
        0x0, 0x0, 0x0, 0x0, 0x3, 0x1c, 0x20, 0x18
    },
    {
        0x0, 0x0, 0x0, 0x0, 0x3, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1c, 0x20, 0x1, 0x0, 0x0, 0x0, 0x0, 0x10, 0x1c,
        0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x1c
    },
    {
        0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x20, 0x2, 0x0, 0x0, 0x0, 0x0, 0x80, 0x4, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0
    },
    {
        0x4, 0x14, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x14, 0x20, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x10, 0x14, 0x20, 0x0, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x2, 0x14, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x22, 0x14, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42, 0x14, 0x20, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x2, 0x14, 0x20, 0x10
    }
};

static const uint8_t patchData2b[20] = {
    0x0, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x20, 0x2, 0x0, 0x0, 0x0, 0x0, 0x22, 0x1c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
};

static const uint8_t patchData2c[25][30] = {
    {
        0x0, 0x0, 0x0, 0x0, 0x4, 0x10, 0x0, 0x0, 0x4, 0x20, 0x0, 0x0, 0x9d, 0x32, 0x0, 0x0, 0x4b, 0x40, 0x0, 0x0, 0x4, 0x50,
        0x0, 0x0, 0x9d, 0x67, 0x0, 0x0, 0x2a, 0x71
    },
    {
        0x0, 0x0, 0x4, 0x80, 0x0, 0x0, 0xbe, 0x71, 0x0, 0x0, 0x4, 0x90, 0x0, 0x0, 0x25, 0x71, 0x0, 0x0, 0x4, 0xa0, 0x0, 0x0,
        0xbe, 0x71, 0x0, 0x0, 0xdd, 0x65, 0x0, 0x0
    },
    {
        0x4, 0xb0, 0x0, 0x0, 0x54, 0x62, 0x0, 0x0, 0x4, 0x50, 0x0, 0x0, 0x6f, 0x66, 0x0, 0x0, 0x48, 0xc5, 0x0, 0x0, 0x2d, 0x61,
        0x0, 0x0, 0x4, 0xd0, 0x0, 0x0, 0xdc, 0x60
    },
    {
        0x0, 0x0, 0xc2, 0xe1, 0x0, 0x0, 0x2c, 0xf1, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0xbe, 0xf1, 0x0, 0x0, 0x4, 0x10, 0x1, 0x0,
        0xe9, 0xf2, 0x0, 0x0, 0x4, 0x20, 0x1, 0x0
    },
    {
        0x9d, 0xf7, 0x0, 0x0, 0x2a, 0x31, 0x1, 0x0, 0x4, 0x40, 0x1, 0x0, 0xbe, 0x31, 0x1, 0x0, 0x4, 0x50, 0x1, 0x0, 0x25, 0x31,
        0x1, 0x0, 0x4, 0x60, 0x1, 0x0, 0x29, 0x31
    },
    {
        0x1, 0x0, 0x94, 0x70, 0x1, 0x0, 0xf0, 0xc2, 0x0, 0x0, 0xe, 0x82, 0x1, 0x0, 0xc2, 0xc1, 0x0, 0x0, 0xc3, 0x61, 0x0, 0x0,
        0x4, 0x90, 0x1, 0x0, 0x6f, 0x66, 0x0, 0x0
    },
    {
        0x48, 0xc5, 0x0, 0x0, 0x2d, 0x61, 0x0, 0x0, 0x4, 0xa0, 0x1, 0x0, 0xdc, 0x60, 0x0, 0x0, 0x4, 0xb0, 0x1, 0x0, 0xbe, 0x31,
        0x0, 0x0, 0x4, 0xc0, 0x1, 0x0, 0xa, 0x30
    },
    {
        0x0, 0x0, 0x4, 0xd0, 0x1, 0x0, 0xa, 0x10, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x10, 0x0, 0x0,
        0x4, 0x20, 0x0, 0x0, 0xe9, 0x32
    },
    {
        0x0, 0x0, 0x4, 0xe0, 0x1, 0x0, 0xc8, 0xf8, 0x1, 0x0, 0x4, 0x0, 0x2, 0x0, 0x8a, 0xfa, 0x1, 0x0, 0x4, 0x10, 0x2, 0x0,
        0x9d, 0xf7, 0x1, 0x0, 0x2a, 0x21, 0x2, 0x0
    },
    {
        0x4, 0x30, 0x2, 0x0, 0xbe, 0x21, 0x2, 0x0, 0x4, 0x40, 0x2, 0x0, 0x25, 0x21, 0x2, 0x0, 0x4, 0x50, 0x2, 0x0, 0xbe, 0x21,
        0x2, 0x0, 0xfe, 0xff, 0x1, 0x0, 0xfe, 0xff
    },
    {
        0x1, 0x0, 0xfe, 0xff, 0x1, 0x0, 0xfe, 0xff, 0x1, 0x0, 0xec, 0xf1, 0x1, 0x0, 0x4b, 0x60, 0x0, 0x0, 0x4, 0x50, 0x0, 0x0,
        0x6f, 0x66, 0x0, 0x0, 0x48, 0xc5, 0x0, 0x0
    },
    {
        0x2d, 0x61, 0x0, 0x0, 0x4, 0xd0, 0x0, 0x0, 0xdc, 0x60, 0x0, 0x0, 0xe, 0x82, 0x1, 0x0, 0xc2, 0xc1, 0x0, 0x0, 0xc3, 0x61,
        0x0, 0x0, 0x4, 0x90, 0x1, 0x0, 0x6f, 0x66
    },
    {
        0x0, 0x0, 0x48, 0xc5, 0x0, 0x0, 0x2d, 0x61, 0x0, 0x0, 0x4, 0xa0, 0x1, 0x0, 0xdc, 0x60, 0x0, 0x0, 0x4, 0x60, 0x2, 0x0,
        0xbe, 0x61, 0x0, 0x0, 0x4, 0xc0, 0x1, 0x0
    },
    {
        0xa, 0x30, 0x0, 0x0, 0x4, 0xd0, 0x1, 0x0, 0x91, 0x10, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x10, 0x0, 0x0, 0x4,
        0x20, 0x0, 0x0, 0x9d, 0x32, 0x0, 0x0
    },
    {
        0x4b, 0x40, 0x0, 0x0, 0x4, 0x90, 0x1, 0x0, 0x9d, 0x67, 0x0, 0x0, 0x2a, 0x71, 0x0, 0x0, 0x4, 0x70, 0x2, 0x0, 0xbe, 0x71,
        0x0, 0x0, 0x4, 0x90, 0x0, 0x0, 0x25, 0x71
    },
    {
        0x0, 0x0, 0x4, 0xa0, 0x0, 0x0, 0xbe, 0x71, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x4, 0xb0, 0x0, 0x0, 0x54, 0x62, 0x0, 0x0,
        0xe, 0x82, 0x1, 0x0, 0xc2, 0xc1, 0x0, 0x0
    },
    {
        0xc3, 0x61, 0x0, 0x0, 0x4, 0x90, 0x1, 0x0, 0x6f, 0x66, 0x0, 0x0, 0x48, 0xc5, 0x0, 0x0, 0x2d, 0x61, 0x0, 0x0, 0x4, 0xa0,
        0x1, 0x0, 0x9, 0x62, 0x0, 0x0, 0x4, 0xb0
    },
    {
        0x1, 0x0, 0xbe, 0x31, 0x0, 0x0, 0x4, 0xc0, 0x1, 0x0, 0xa, 0x30, 0x0, 0x0, 0xf, 0x10, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    },
    {
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x4, 0x10
    },
    {
        0x0, 0x0, 0x4, 0x20, 0x0, 0x0, 0x9d, 0x32, 0x0, 0x0, 0x4b, 0x40, 0x0, 0x0, 0x4, 0x50, 0x0, 0x0, 0x9d, 0x67, 0x0, 0x0,
        0x2a, 0x71, 0x0, 0x0, 0x4, 0x80, 0x0, 0x0
    },
    {
        0xbe, 0x71, 0x0, 0x0, 0x4, 0x90, 0x0, 0x0, 0x25, 0x71, 0x0, 0x0, 0x4, 0xa0, 0x0, 0x0, 0xbe, 0x71, 0x0, 0x0, 0x0, 0x60,
        0x0, 0x0, 0x4, 0xb0, 0x0, 0x0, 0x54, 0x62
    },
    {
        0x0, 0x0, 0xe, 0x82, 0x1, 0x0, 0xc2, 0xc1, 0x0, 0x0, 0xc3, 0x61, 0x0, 0x0, 0x4, 0x50, 0x0, 0x0, 0x6f, 0x66, 0x0, 0x0,
        0x48, 0xc5, 0x0, 0x0, 0x2d, 0x61, 0x0, 0x0
    },
    {
        0x4, 0xd0, 0x0, 0x0, 0x9, 0x62, 0x0, 0x0, 0x4, 0xb0, 0x1, 0x0, 0xbe, 0x31, 0x0, 0x0, 0x4, 0xc0, 0x1, 0x0, 0xa, 0x30,
        0x0, 0x0, 0x4, 0xd0, 0x1, 0x0, 0xa, 0x10
    }
};

static const uint8_t patchData2d[6] = {0x0, 0x0, 0x0, 0x0, 0x60, 0x0};

static uint8_t multi_polling(omv_csi_t *csi,
                             uint32_t num_cycles,
                             uint16_t reg_index,
                             uint8_t expected,
                             uint8_t mask,
                             uint32_t timeout) {

    uint8_t read_data;

    for (int i = 0; i < num_cycles; i++) {
        omv_i3c_readb2(csi->i2c, csi->slv_addr, reg_index, &read_data);

        if ((read_data & mask) == expected) {
            return 0;
        }
        mp_hal_delay_ms(timeout);
    }
    return 1;     //Failed to read correct value
}

static uint8_t write_patch(omv_csi_t *csi, uint16_t reg_index, const uint8_t *data, uint32_t data_length) {
    uint8_t write_data[34];

    write_data[0] = (reg_index >> 8) & 0xff;
    write_data[1] = reg_index & 0xff;

    memcpy(write_data + 2, data, data_length);
    return omv_i3c_write_bytes(csi->i2c, csi->slv_addr, write_data, data_length + 2, OMV_I2C_XFER_NO_FLAGS);
}

static int reset(omv_csi_t *csi) {
    int ret = 0;

    uint16_t reg_index = 0x2000;
    // ===================
    // Power up the device
    // ===================

    // Wait sensor to wake up
    multi_polling(csi, 5, UI_STATUS_DEVICE_MODEL_ID + 3, 0x53, 0xFF, 1);    // (val=1396000561) / UI.STATUS.DEVICE_MODEL_ID
    multi_polling(csi, 5, UI_STATUS_DEVICE_MODEL_ID + 2, 0x35, 0xFF, 1);   // (val=1396000561) / UI.STATUS.DEVICE_MODEL_ID
    multi_polling(csi, 5, UI_STATUS_DEVICE_MODEL_ID + 1, 0x47, 0xFF, 1);   // (val=1396000561) / UI.STATUS.DEVICE_MODEL_ID
    multi_polling(csi, 5, UI_STATUS_DEVICE_MODEL_ID, 0x31, 0xFF, 1);     // (val=1396000561) / UI.STATUS.DEVICE_MODEL_ID

    // Wait FSM to be READY_TO_BOOT
    mp_hal_delay_ms(2);
    multi_polling(csi, 5, VD55G1_SYSTEM_FSM, 0x1, 0xFF, 0);     // (val=1) UI.STATUS.SYSTEM_FSM.VALUE


    // ===========================
    // Operations in READY_TO_BOOT
    // ===========================

    // Load patch (2.0)

    for (int i = 0; i < 25; i++) {
        write_patch(csi, reg_index, &patchData1a[i][0], 30);
        reg_index += 30;
    }

    write_patch(csi, reg_index, &patchData1b[0], 26);

    // Run command PATCH_AND_BOOT
    omv_i2c_writeb2(csi->i2c, csi->slv_addr, UI_CMD_BOOT_COMMAND, 0x2); // (val=2) / UI.CMD.BOOT.COMMAND
    mp_hal_delay_ms(200);
    ret = multi_polling(csi, 18, 0x0200, 0x0, 0x3, 1);     // (val=0) UI.CMD.BOOT.COMMAND
    printf("Run Patch and Boot: %d\n", ret);

    // Wait FSM to be SW_STBY
    mp_hal_delay_ms(200);
    ret = multi_polling(csi, 5, VD55G1_SYSTEM_FSM, 0x2, 0xFF, 0);     // (val=2) UI.STATUS.SYSTEM_FSM.VALUE
    printf("Wait FSM to be in SW Standby: %d\n", ret);

    // Run command START_VTRAM_UPDATE
    omv_i2c_writeb2(csi->i2c, csi->slv_addr, VD55G1_CMD_STBY, 0x6);
    mp_hal_delay_ms(200);
    ret = multi_polling(csi, 4, VD55G1_CMD_STBY, 0x0, 0xf, 1);     // (val=0) UI.CMD.STBY.COMMAND
    printf("Run command START_VTRAM_UPDATE: %d\n", ret);

    // write_2bytes(csi, 0xc638, 0x21, 0x0); // 0xc638
    omv_i3c_writew2(csi->i2c, csi->slv_addr, 0xc638, 0x0021);

    reg_index = 0xc3c0;
    for (int i = 0; i < 10; i++) {
        write_patch(csi, reg_index, &patchData2a[i][0], 30);
        reg_index += 30;
    }

    write_patch(csi, reg_index, &patchData2b[0], 20);

    reg_index = 0xc640;
    for (int i = 0; i < 25; i++) {
        write_patch(csi, reg_index, &patchData2c[i][0], 30);
        reg_index += 30;
    }

    write_patch(csi, reg_index, &patchData2d[0], 6);

    // Run command END_VTRAM_UPDATE
    omv_i2c_writeb2(csi->i2c, csi->slv_addr, VD55G1_CMD_STBY, 0x7);
    mp_hal_delay_ms(200);
    ret = multi_polling(csi, 4, VD55G1_CMD_STBY, 0x0, 0xf, 1);     // (val=0) UI.CMD.STBY.COMMAND //not working on 10/11
    // printf("Run command END_VTRAM_UPDATE: %d\n",ReturnValue);

    // =====================
    // Operations in SW_STBY
    // =====================
    // Set frequencies
    omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_SENSOR_SETTINGS_EXT_CLOCK_VALUE, /*0xb71b00*/ 12000000); // External clock = 12.00 MHz
    omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_SENSOR_SETTINGS_MIPI_DATA_RATE_VALUE, /*0x47868c00*/ 1200000000); // Csi frequency = 1200.00 Mbps
    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_STATICS_LINE_LENGTH_VALUE, /*0x0468*/ 1128); // Line time = 7.52 us

    omv_i2c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, 0x0); // Auto-exposure

    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_FRAME_LENGTH_VALUE, /*0x0a63*/ 2659); // 50 fps

    omv_i2c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_GPIO_0_CTRL, 0x2); // Strobe

    // omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_STATICS_LINE_LENGTH_VALUE, /*0xafc8*/ 45000);
    // omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_FRAME_LENGTH_VALUE, /*0x0682*/ 1666);
    // omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_STREAM_CTX1_FRAME_LENGTH_VALUE, /*0x00000682*/ 1666);
    // omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_STREAM_CTX2_FRAME_LENGTH_VALUE, /*0x00000682*/ 1666);
    // omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_STREAM_CTX3_FRAME_LENGTH_VALUE, /*0x00000682*/ 1666);

    // omv_i2c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_GPIO_0_CTRL, /*0x0c*/ 12);

    omv_i2c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_READOUT_CTRL, 0x1); // ctx0 READOUT_CTRL, 2x binning

    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_X_WIDTH, /*0x0320*/ 800);
    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_X_START, /*0x0000*/ 0);
    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_Y_HEIGHT, /*0x02b8*/ 696);
    omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_Y_START, /*0x0000*/ 0);

    return ret;
}

static int sleep(omv_csi_t *csi, int enable) {
    // int ret = omv_i3c_writeb2(csi->i2c, csi->slv_addr, SENSOR_TG_EN, SENSOR_TG_EN_FLAG);
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, SENSOR_OPMODE,
    //                        enable ? SENSOR_OPMODE_SUSPEND : SENSOR_OPMODE_RUN);
    return 0;
}

static int read_reg(omv_csi_t *csi, uint16_t reg) {
    uint8_t reg_data;
    if (omv_i3c_readb2(csi->i2c, csi->slv_addr, reg, &reg_data) != 0) {
        return -1;
    }
    return reg_data;
}

static int write_reg(omv_csi_t *csi, uint16_t reg, uint16_t reg_data) {
    return omv_i3c_writeb2(csi->i2c, csi->slv_addr, reg, reg_data);
}

static int set_pixformat(omv_csi_t *csi, pixformat_t pixformat) {
    switch (pixformat) {
        case PIXFORMAT_RGB565:
        case PIXFORMAT_BAYER:
        case PIXFORMAT_GRAYSCALE:
            return 0;
        default:
            return -1;
    }
}

static int set_framesize(omv_csi_t *csi, omv_csi_framesize_t framesize) {
    int ret = 0;

    switch (framesize) {
        case OMV_CSI_FRAMESIZE_VGA:
        case OMV_CSI_FRAMESIZE_QVGA:
        case OMV_CSI_FRAMESIZE_HQVGA:
            break;
        default:
            return -1;
    }

    ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_X_WIDTH, csi->resolution[framesize][0]);
    ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_X_START, 0);
    ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_Y_HEIGHT, csi->resolution[framesize][1]);
    ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_Y_START, 0);

    // csi->framesize = framesize;
    // set_framerate(csi, 60);

    return ret;
}

static int set_framerate(omv_csi_t *csi, int framerate) {
    int ret = 0;
    uint8_t exposure_mode;
    uint16_t exposure_us;

    switch (csi->framesize) {
        case OMV_CSI_FRAMESIZE_VGA:
            framerate = IM_MIN(framerate, VD551G1_VGA_FPS_MAX);
            break;
        case OMV_CSI_FRAMESIZE_QVGA:
            framerate = IM_MIN(framerate, VD551G1_QVGA_FPS_MAX);
            break;
        case OMV_CSI_FRAMESIZE_HQVGA:
            framerate = IM_MIN(framerate, VD551G1_HQVGA_FPS_MAX);
            break;
        default:
            return -1;
    }

    int32_t frame_time = FT_CLK / framerate;

    omv_i3c_writedw2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_FRAME_LENGTH_VALUE, frame_time);

    ret |= omv_i3c_readb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, &exposure_mode);

    if (exposure_mode == 0x02) {
        ret |= omv_i3c_readw2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A, &exposure_us);
        // ret |= omv_i3c_readw2(csi->i2c, csi->slv_addr, EXPOSURE_STEP_PROPORTION_A, &exposure_us);

        exposure_us = IM_CLAMP((int32_t) exposure_us, VD551G1_EXP_MIN, (frame_time - VD551G1_EXP_OFFSET)) / VD551G1_EXP_DIV;

        ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A, exposure_us);
    }

    return ret;
}

static int set_gainceiling(omv_csi_t *csi, omv_csi_gainceiling_t gainceiling) {
    return 0;
}

static int set_colorbar(omv_csi_t *csi, int enable) {
    // uint8_t reg;
    // int ret = omv_i3c_readb2(csi->i2c, csi->slv_addr, ISP_EN_H, &reg);
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, ISP_EN_H,
    //                        (reg & ~ISP_EN_H_EN) | (enable ? ISP_EN_H_EN : 0));
    // ret |= omv_i3c_readb2(csi->i2c, csi->slv_addr, ISP_TEST_MODE, &reg);
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, ISP_TEST_MODE,
    //                        (reg & ~ISP_TEST_MODE_RAMP) | (enable ? ISP_TEST_MODE_RAMP : 0));
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, SENSOR_UPDATE, SENSOR_UPDATE_FLAG);
    // return ret;
    return -1;
}

static int set_auto_gain(omv_csi_t *csi, int enable, float gain_db, float gain_db_ceiling) {
    int ret = 0;

    if (enable == 1) {
        ret = omv_i3c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, 0x00);
    } else {
        ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, 0x02);
        // analog gain = 32 / (32 âˆ’ MANUAL_ANALOG_GAIN)
        ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_ANALOG_GAIN, (uint8_t) (powf(10, gain_db) / 20.0f));
    }

    // config.AutoGain = enable;
    // config.AnalogGain =  gain_db;

    return 0;

}

static int get_gain_db(omv_csi_t *csi, float *gain_db) {
    uint8_t gain;
    int ret = 0;

    ret = omv_i3c_readb2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_ANALOG_GAIN, &gain);

    *gain_db = 20.0f * log10f(gain);

    return ret;
}

static int set_auto_exposure(omv_csi_t *csi, int enable, int exposure_us) {
    int ret = 0;

    if (enable == 1) {
        // exposure_required = exposure_current * statistic_target / statistic_current
        ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, 0x0);
    } else{
        ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, UI_STREAM_CTX0_EXPOSURE_MODE_MODE, 0x2);
        ret |= omv_i3c_writew2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A, (uint16_t) exposure_us);
    }

    return ret;
}

static int get_exposure_us(omv_csi_t *csi, int *exposure_us) {
    int ret = 0;
    uint16_t exposure_us_raw;

    ret |= omv_i3c_readw2(csi->i2c, csi->slv_addr, EXPOSURE_MANUAL_COARSE_EXPOSURE_LINES_A, &exposure_us_raw);
    // ret |= omv_i3c_readw2(csi->i2c, csi->slv_addr, EXPOSURE_STEP_PROPORTION_A, &exposure_us_raw);

    *exposure_us = (int) exposure_us_raw;

    return ret;
}

static int set_hmirror(omv_csi_t *csi, int enable) {
    // uint8_t reg;
    // int ret = omv_i3c_readb2(csi->i2c, csi->slv_addr, TG_FLIP, &reg);
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, TG_FLIP, TG_FLIP_SET_HFLIP(reg, enable));
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, SENSOR_UPDATE, SENSOR_UPDATE_FLAG);
    // return ret;
    return -1;
}

static int set_vflip(omv_csi_t *csi, int enable) {
    // uint8_t reg;
    // int ret = omv_i3c_readb2(csi->i2c, csi->slv_addr, TG_FLIP, &reg);
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, TG_FLIP, TG_FLIP_SET_VFLIP(reg, enable));
    // ret |= omv_i3c_writeb2(csi->i2c, csi->slv_addr, SENSOR_UPDATE, SENSOR_UPDATE_FLAG);
    // return ret;
    return -1;
}

static int ioctl(omv_csi_t *csi, int request, va_list ap) {
    int ret = 0;

    switch (request) {
        default: {
            ret = -1;
            break;
        }
    }

    return ret;
}

int vd551g1_init(omv_csi_t *csi) {
    // Initialize csi flags.
    csi->vsync_pol = 0;
    csi->hsync_pol = 0;
    csi->pixck_pol = 1;
    csi->mono_bpp = 1;
    csi->raw_output = 1;
    csi->cfa_format = SUBFORMAT_ID_BGGR;
    #if OMV_VD551G1_MIPI_CSI2
    csi->mipi_if = 1;
    csi->mipi_brate = 1200;
    #endif

    // Initialize csi ops.
    csi->reset = reset;
    csi->sleep = sleep;
    csi->ioctl = ioctl;
    csi->read_reg = read_reg;
    csi->write_reg = write_reg;
    csi->set_pixformat = set_pixformat;
    csi->set_framesize = set_framesize;
    csi->set_framerate = set_framerate;
    csi->set_gainceiling = set_gainceiling;
    csi->set_colorbar = set_colorbar;
    csi->set_auto_gain = set_auto_gain;
    csi->get_gain_db = get_gain_db;
    csi->set_auto_exposure = set_auto_exposure;
    csi->get_exposure_us = get_exposure_us;
    csi->set_hmirror = set_hmirror;
    csi->set_vflip = set_vflip;

    // Override standard resolutions
    csi->resolution[OMV_CSI_FRAMESIZE_VGA][0] = 700;
    csi->resolution[OMV_CSI_FRAMESIZE_VGA][1] = 400;

    csi->resolution[OMV_CSI_FRAMESIZE_QVGA][0] = 400;
    csi->resolution[OMV_CSI_FRAMESIZE_QVGA][1] = 200;

    csi->resolution[OMV_CSI_FRAMESIZE_HQVGA][0] = 200;
    csi->resolution[OMV_CSI_FRAMESIZE_HQVGA][1] = 100;
    return 0;
}
#endif // (OMV_VD551G1_ENABLE == 1)
