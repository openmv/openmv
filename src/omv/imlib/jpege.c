/*
 * SPDX-License-Identifier: MIT
 *
 * Copyright (C) 2013-2024 OpenMV, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Minimalistic JPEG baseline encoder.
 * Ported from public domain JPEG writer by Jon Olick - http://jonolick.com
 * DCT implementation is based on Arai, Agui, and Nakajima's algorithm for scaled DCT.
 */
#include "imlib.h"
#include "file_utils.h"

// Expand 4 bits to 32 for binary to grayscale - process 4 pixels at a time
#if (OMV_JPEG_CODEC_ENABLE == 1)
#define JPEG_BINARY_0              0x00
#define JPEG_BINARY_1              0xFF
static const uint32_t jpeg_expand[16] = {
    0x00000000, 0x000000ff, 0x0000ff00, 0x0000ffff,
    0x00ff0000, 0x00ff00ff, 0x00ffff00, 0x00ffffff,
    0xff000000, 0xff0000ff, 0xff00ff00, 0xff00ffff,
    0xffff0000, 0xffff00ff, 0xffffff00, 0xffffffff
};
#else
#define JPEG_BINARY_0              0x80
#define JPEG_BINARY_1              0x7F
static const uint32_t jpeg_expand[16] = {
    0x80808080, 0x8080807f, 0x80807f80, 0x80807f7f,
    0x807f8080, 0x807f807f, 0x807f7f80, 0x807f7f7f,
    0x7f808080, 0x7f80807f, 0x7f807f80, 0x7f807f7f,
    0x7f7f8080, 0x7f7f807f, 0x7f7f7f80, 0x7f7f7f7f
};
#endif
// Returns the magnitude and fixes negative values for JPEG encoding
// Upper 16 bits is the new delta value, lower 16 is the magnitude
const uint32_t ulMagnitudeFix[2048] = {
    0x03ff000b, 0x0000000a, 0x0001000a, 0x0002000a, 0x0003000a, 0x0004000a, 0x0005000a, 0x0006000a,
    0x0007000a, 0x0008000a, 0x0009000a, 0x000a000a, 0x000b000a, 0x000c000a, 0x000d000a, 0x000e000a,
    0x000f000a, 0x0010000a, 0x0011000a, 0x0012000a, 0x0013000a, 0x0014000a, 0x0015000a, 0x0016000a,
    0x0017000a, 0x0018000a, 0x0019000a, 0x001a000a, 0x001b000a, 0x001c000a, 0x001d000a, 0x001e000a,
    0x001f000a, 0x0020000a, 0x0021000a, 0x0022000a, 0x0023000a, 0x0024000a, 0x0025000a, 0x0026000a,
    0x0027000a, 0x0028000a, 0x0029000a, 0x002a000a, 0x002b000a, 0x002c000a, 0x002d000a, 0x002e000a,
    0x002f000a, 0x0030000a, 0x0031000a, 0x0032000a, 0x0033000a, 0x0034000a, 0x0035000a, 0x0036000a,
    0x0037000a, 0x0038000a, 0x0039000a, 0x003a000a, 0x003b000a, 0x003c000a, 0x003d000a, 0x003e000a,
    0x003f000a, 0x0040000a, 0x0041000a, 0x0042000a, 0x0043000a, 0x0044000a, 0x0045000a, 0x0046000a,
    0x0047000a, 0x0048000a, 0x0049000a, 0x004a000a, 0x004b000a, 0x004c000a, 0x004d000a, 0x004e000a,
    0x004f000a, 0x0050000a, 0x0051000a, 0x0052000a, 0x0053000a, 0x0054000a, 0x0055000a, 0x0056000a,
    0x0057000a, 0x0058000a, 0x0059000a, 0x005a000a, 0x005b000a, 0x005c000a, 0x005d000a, 0x005e000a,
    0x005f000a, 0x0060000a, 0x0061000a, 0x0062000a, 0x0063000a, 0x0064000a, 0x0065000a, 0x0066000a,
    0x0067000a, 0x0068000a, 0x0069000a, 0x006a000a, 0x006b000a, 0x006c000a, 0x006d000a, 0x006e000a,
    0x006f000a, 0x0070000a, 0x0071000a, 0x0072000a, 0x0073000a, 0x0074000a, 0x0075000a, 0x0076000a,
    0x0077000a, 0x0078000a, 0x0079000a, 0x007a000a, 0x007b000a, 0x007c000a, 0x007d000a, 0x007e000a,
    0x007f000a, 0x0080000a, 0x0081000a, 0x0082000a, 0x0083000a, 0x0084000a, 0x0085000a, 0x0086000a,
    0x0087000a, 0x0088000a, 0x0089000a, 0x008a000a, 0x008b000a, 0x008c000a, 0x008d000a, 0x008e000a,
    0x008f000a, 0x0090000a, 0x0091000a, 0x0092000a, 0x0093000a, 0x0094000a, 0x0095000a, 0x0096000a,
    0x0097000a, 0x0098000a, 0x0099000a, 0x009a000a, 0x009b000a, 0x009c000a, 0x009d000a, 0x009e000a,
    0x009f000a, 0x00a0000a, 0x00a1000a, 0x00a2000a, 0x00a3000a, 0x00a4000a, 0x00a5000a, 0x00a6000a,
    0x00a7000a, 0x00a8000a, 0x00a9000a, 0x00aa000a, 0x00ab000a, 0x00ac000a, 0x00ad000a, 0x00ae000a,
    0x00af000a, 0x00b0000a, 0x00b1000a, 0x00b2000a, 0x00b3000a, 0x00b4000a, 0x00b5000a, 0x00b6000a,
    0x00b7000a, 0x00b8000a, 0x00b9000a, 0x00ba000a, 0x00bb000a, 0x00bc000a, 0x00bd000a, 0x00be000a,
    0x00bf000a, 0x00c0000a, 0x00c1000a, 0x00c2000a, 0x00c3000a, 0x00c4000a, 0x00c5000a, 0x00c6000a,
    0x00c7000a, 0x00c8000a, 0x00c9000a, 0x00ca000a, 0x00cb000a, 0x00cc000a, 0x00cd000a, 0x00ce000a,
    0x00cf000a, 0x00d0000a, 0x00d1000a, 0x00d2000a, 0x00d3000a, 0x00d4000a, 0x00d5000a, 0x00d6000a,
    0x00d7000a, 0x00d8000a, 0x00d9000a, 0x00da000a, 0x00db000a, 0x00dc000a, 0x00dd000a, 0x00de000a,
    0x00df000a, 0x00e0000a, 0x00e1000a, 0x00e2000a, 0x00e3000a, 0x00e4000a, 0x00e5000a, 0x00e6000a,
    0x00e7000a, 0x00e8000a, 0x00e9000a, 0x00ea000a, 0x00eb000a, 0x00ec000a, 0x00ed000a, 0x00ee000a,
    0x00ef000a, 0x00f0000a, 0x00f1000a, 0x00f2000a, 0x00f3000a, 0x00f4000a, 0x00f5000a, 0x00f6000a,
    0x00f7000a, 0x00f8000a, 0x00f9000a, 0x00fa000a, 0x00fb000a, 0x00fc000a, 0x00fd000a, 0x00fe000a,
    0x00ff000a, 0x0100000a, 0x0101000a, 0x0102000a, 0x0103000a, 0x0104000a, 0x0105000a, 0x0106000a,
    0x0107000a, 0x0108000a, 0x0109000a, 0x010a000a, 0x010b000a, 0x010c000a, 0x010d000a, 0x010e000a,
    0x010f000a, 0x0110000a, 0x0111000a, 0x0112000a, 0x0113000a, 0x0114000a, 0x0115000a, 0x0116000a,
    0x0117000a, 0x0118000a, 0x0119000a, 0x011a000a, 0x011b000a, 0x011c000a, 0x011d000a, 0x011e000a,
    0x011f000a, 0x0120000a, 0x0121000a, 0x0122000a, 0x0123000a, 0x0124000a, 0x0125000a, 0x0126000a,
    0x0127000a, 0x0128000a, 0x0129000a, 0x012a000a, 0x012b000a, 0x012c000a, 0x012d000a, 0x012e000a,
    0x012f000a, 0x0130000a, 0x0131000a, 0x0132000a, 0x0133000a, 0x0134000a, 0x0135000a, 0x0136000a,
    0x0137000a, 0x0138000a, 0x0139000a, 0x013a000a, 0x013b000a, 0x013c000a, 0x013d000a, 0x013e000a,
    0x013f000a, 0x0140000a, 0x0141000a, 0x0142000a, 0x0143000a, 0x0144000a, 0x0145000a, 0x0146000a,
    0x0147000a, 0x0148000a, 0x0149000a, 0x014a000a, 0x014b000a, 0x014c000a, 0x014d000a, 0x014e000a,
    0x014f000a, 0x0150000a, 0x0151000a, 0x0152000a, 0x0153000a, 0x0154000a, 0x0155000a, 0x0156000a,
    0x0157000a, 0x0158000a, 0x0159000a, 0x015a000a, 0x015b000a, 0x015c000a, 0x015d000a, 0x015e000a,
    0x015f000a, 0x0160000a, 0x0161000a, 0x0162000a, 0x0163000a, 0x0164000a, 0x0165000a, 0x0166000a,
    0x0167000a, 0x0168000a, 0x0169000a, 0x016a000a, 0x016b000a, 0x016c000a, 0x016d000a, 0x016e000a,
    0x016f000a, 0x0170000a, 0x0171000a, 0x0172000a, 0x0173000a, 0x0174000a, 0x0175000a, 0x0176000a,
    0x0177000a, 0x0178000a, 0x0179000a, 0x017a000a, 0x017b000a, 0x017c000a, 0x017d000a, 0x017e000a,
    0x017f000a, 0x0180000a, 0x0181000a, 0x0182000a, 0x0183000a, 0x0184000a, 0x0185000a, 0x0186000a,
    0x0187000a, 0x0188000a, 0x0189000a, 0x018a000a, 0x018b000a, 0x018c000a, 0x018d000a, 0x018e000a,
    0x018f000a, 0x0190000a, 0x0191000a, 0x0192000a, 0x0193000a, 0x0194000a, 0x0195000a, 0x0196000a,
    0x0197000a, 0x0198000a, 0x0199000a, 0x019a000a, 0x019b000a, 0x019c000a, 0x019d000a, 0x019e000a,
    0x019f000a, 0x01a0000a, 0x01a1000a, 0x01a2000a, 0x01a3000a, 0x01a4000a, 0x01a5000a, 0x01a6000a,
    0x01a7000a, 0x01a8000a, 0x01a9000a, 0x01aa000a, 0x01ab000a, 0x01ac000a, 0x01ad000a, 0x01ae000a,
    0x01af000a, 0x01b0000a, 0x01b1000a, 0x01b2000a, 0x01b3000a, 0x01b4000a, 0x01b5000a, 0x01b6000a,
    0x01b7000a, 0x01b8000a, 0x01b9000a, 0x01ba000a, 0x01bb000a, 0x01bc000a, 0x01bd000a, 0x01be000a,
    0x01bf000a, 0x01c0000a, 0x01c1000a, 0x01c2000a, 0x01c3000a, 0x01c4000a, 0x01c5000a, 0x01c6000a,
    0x01c7000a, 0x01c8000a, 0x01c9000a, 0x01ca000a, 0x01cb000a, 0x01cc000a, 0x01cd000a, 0x01ce000a,
    0x01cf000a, 0x01d0000a, 0x01d1000a, 0x01d2000a, 0x01d3000a, 0x01d4000a, 0x01d5000a, 0x01d6000a,
    0x01d7000a, 0x01d8000a, 0x01d9000a, 0x01da000a, 0x01db000a, 0x01dc000a, 0x01dd000a, 0x01de000a,
    0x01df000a, 0x01e0000a, 0x01e1000a, 0x01e2000a, 0x01e3000a, 0x01e4000a, 0x01e5000a, 0x01e6000a,
    0x01e7000a, 0x01e8000a, 0x01e9000a, 0x01ea000a, 0x01eb000a, 0x01ec000a, 0x01ed000a, 0x01ee000a,
    0x01ef000a, 0x01f0000a, 0x01f1000a, 0x01f2000a, 0x01f3000a, 0x01f4000a, 0x01f5000a, 0x01f6000a,
    0x01f7000a, 0x01f8000a, 0x01f9000a, 0x01fa000a, 0x01fb000a, 0x01fc000a, 0x01fd000a, 0x01fe000a,
    0x01ff000a, 0x00000009, 0x00010009, 0x00020009, 0x00030009, 0x00040009, 0x00050009, 0x00060009,
    0x00070009, 0x00080009, 0x00090009, 0x000a0009, 0x000b0009, 0x000c0009, 0x000d0009, 0x000e0009,
    0x000f0009, 0x00100009, 0x00110009, 0x00120009, 0x00130009, 0x00140009, 0x00150009, 0x00160009,
    0x00170009, 0x00180009, 0x00190009, 0x001a0009, 0x001b0009, 0x001c0009, 0x001d0009, 0x001e0009,
    0x001f0009, 0x00200009, 0x00210009, 0x00220009, 0x00230009, 0x00240009, 0x00250009, 0x00260009,
    0x00270009, 0x00280009, 0x00290009, 0x002a0009, 0x002b0009, 0x002c0009, 0x002d0009, 0x002e0009,
    0x002f0009, 0x00300009, 0x00310009, 0x00320009, 0x00330009, 0x00340009, 0x00350009, 0x00360009,
    0x00370009, 0x00380009, 0x00390009, 0x003a0009, 0x003b0009, 0x003c0009, 0x003d0009, 0x003e0009,
    0x003f0009, 0x00400009, 0x00410009, 0x00420009, 0x00430009, 0x00440009, 0x00450009, 0x00460009,
    0x00470009, 0x00480009, 0x00490009, 0x004a0009, 0x004b0009, 0x004c0009, 0x004d0009, 0x004e0009,
    0x004f0009, 0x00500009, 0x00510009, 0x00520009, 0x00530009, 0x00540009, 0x00550009, 0x00560009,
    0x00570009, 0x00580009, 0x00590009, 0x005a0009, 0x005b0009, 0x005c0009, 0x005d0009, 0x005e0009,
    0x005f0009, 0x00600009, 0x00610009, 0x00620009, 0x00630009, 0x00640009, 0x00650009, 0x00660009,
    0x00670009, 0x00680009, 0x00690009, 0x006a0009, 0x006b0009, 0x006c0009, 0x006d0009, 0x006e0009,
    0x006f0009, 0x00700009, 0x00710009, 0x00720009, 0x00730009, 0x00740009, 0x00750009, 0x00760009,
    0x00770009, 0x00780009, 0x00790009, 0x007a0009, 0x007b0009, 0x007c0009, 0x007d0009, 0x007e0009,
    0x007f0009, 0x00800009, 0x00810009, 0x00820009, 0x00830009, 0x00840009, 0x00850009, 0x00860009,
    0x00870009, 0x00880009, 0x00890009, 0x008a0009, 0x008b0009, 0x008c0009, 0x008d0009, 0x008e0009,
    0x008f0009, 0x00900009, 0x00910009, 0x00920009, 0x00930009, 0x00940009, 0x00950009, 0x00960009,
    0x00970009, 0x00980009, 0x00990009, 0x009a0009, 0x009b0009, 0x009c0009, 0x009d0009, 0x009e0009,
    0x009f0009, 0x00a00009, 0x00a10009, 0x00a20009, 0x00a30009, 0x00a40009, 0x00a50009, 0x00a60009,
    0x00a70009, 0x00a80009, 0x00a90009, 0x00aa0009, 0x00ab0009, 0x00ac0009, 0x00ad0009, 0x00ae0009,
    0x00af0009, 0x00b00009, 0x00b10009, 0x00b20009, 0x00b30009, 0x00b40009, 0x00b50009, 0x00b60009,
    0x00b70009, 0x00b80009, 0x00b90009, 0x00ba0009, 0x00bb0009, 0x00bc0009, 0x00bd0009, 0x00be0009,
    0x00bf0009, 0x00c00009, 0x00c10009, 0x00c20009, 0x00c30009, 0x00c40009, 0x00c50009, 0x00c60009,
    0x00c70009, 0x00c80009, 0x00c90009, 0x00ca0009, 0x00cb0009, 0x00cc0009, 0x00cd0009, 0x00ce0009,
    0x00cf0009, 0x00d00009, 0x00d10009, 0x00d20009, 0x00d30009, 0x00d40009, 0x00d50009, 0x00d60009,
    0x00d70009, 0x00d80009, 0x00d90009, 0x00da0009, 0x00db0009, 0x00dc0009, 0x00dd0009, 0x00de0009,
    0x00df0009, 0x00e00009, 0x00e10009, 0x00e20009, 0x00e30009, 0x00e40009, 0x00e50009, 0x00e60009,
    0x00e70009, 0x00e80009, 0x00e90009, 0x00ea0009, 0x00eb0009, 0x00ec0009, 0x00ed0009, 0x00ee0009,
    0x00ef0009, 0x00f00009, 0x00f10009, 0x00f20009, 0x00f30009, 0x00f40009, 0x00f50009, 0x00f60009,
    0x00f70009, 0x00f80009, 0x00f90009, 0x00fa0009, 0x00fb0009, 0x00fc0009, 0x00fd0009, 0x00fe0009,
    0x00ff0009, 0x00000008, 0x00010008, 0x00020008, 0x00030008, 0x00040008, 0x00050008, 0x00060008,
    0x00070008, 0x00080008, 0x00090008, 0x000a0008, 0x000b0008, 0x000c0008, 0x000d0008, 0x000e0008,
    0x000f0008, 0x00100008, 0x00110008, 0x00120008, 0x00130008, 0x00140008, 0x00150008, 0x00160008,
    0x00170008, 0x00180008, 0x00190008, 0x001a0008, 0x001b0008, 0x001c0008, 0x001d0008, 0x001e0008,
    0x001f0008, 0x00200008, 0x00210008, 0x00220008, 0x00230008, 0x00240008, 0x00250008, 0x00260008,
    0x00270008, 0x00280008, 0x00290008, 0x002a0008, 0x002b0008, 0x002c0008, 0x002d0008, 0x002e0008,
    0x002f0008, 0x00300008, 0x00310008, 0x00320008, 0x00330008, 0x00340008, 0x00350008, 0x00360008,
    0x00370008, 0x00380008, 0x00390008, 0x003a0008, 0x003b0008, 0x003c0008, 0x003d0008, 0x003e0008,
    0x003f0008, 0x00400008, 0x00410008, 0x00420008, 0x00430008, 0x00440008, 0x00450008, 0x00460008,
    0x00470008, 0x00480008, 0x00490008, 0x004a0008, 0x004b0008, 0x004c0008, 0x004d0008, 0x004e0008,
    0x004f0008, 0x00500008, 0x00510008, 0x00520008, 0x00530008, 0x00540008, 0x00550008, 0x00560008,
    0x00570008, 0x00580008, 0x00590008, 0x005a0008, 0x005b0008, 0x005c0008, 0x005d0008, 0x005e0008,
    0x005f0008, 0x00600008, 0x00610008, 0x00620008, 0x00630008, 0x00640008, 0x00650008, 0x00660008,
    0x00670008, 0x00680008, 0x00690008, 0x006a0008, 0x006b0008, 0x006c0008, 0x006d0008, 0x006e0008,
    0x006f0008, 0x00700008, 0x00710008, 0x00720008, 0x00730008, 0x00740008, 0x00750008, 0x00760008,
    0x00770008, 0x00780008, 0x00790008, 0x007a0008, 0x007b0008, 0x007c0008, 0x007d0008, 0x007e0008,
    0x007f0008, 0x00000007, 0x00010007, 0x00020007, 0x00030007, 0x00040007, 0x00050007, 0x00060007,
    0x00070007, 0x00080007, 0x00090007, 0x000a0007, 0x000b0007, 0x000c0007, 0x000d0007, 0x000e0007,
    0x000f0007, 0x00100007, 0x00110007, 0x00120007, 0x00130007, 0x00140007, 0x00150007, 0x00160007,
    0x00170007, 0x00180007, 0x00190007, 0x001a0007, 0x001b0007, 0x001c0007, 0x001d0007, 0x001e0007,
    0x001f0007, 0x00200007, 0x00210007, 0x00220007, 0x00230007, 0x00240007, 0x00250007, 0x00260007,
    0x00270007, 0x00280007, 0x00290007, 0x002a0007, 0x002b0007, 0x002c0007, 0x002d0007, 0x002e0007,
    0x002f0007, 0x00300007, 0x00310007, 0x00320007, 0x00330007, 0x00340007, 0x00350007, 0x00360007,
    0x00370007, 0x00380007, 0x00390007, 0x003a0007, 0x003b0007, 0x003c0007, 0x003d0007, 0x003e0007,
    0x003f0007, 0x00000006, 0x00010006, 0x00020006, 0x00030006, 0x00040006, 0x00050006, 0x00060006,
    0x00070006, 0x00080006, 0x00090006, 0x000a0006, 0x000b0006, 0x000c0006, 0x000d0006, 0x000e0006,
    0x000f0006, 0x00100006, 0x00110006, 0x00120006, 0x00130006, 0x00140006, 0x00150006, 0x00160006,
    0x00170006, 0x00180006, 0x00190006, 0x001a0006, 0x001b0006, 0x001c0006, 0x001d0006, 0x001e0006,
    0x001f0006, 0x00000005, 0x00010005, 0x00020005, 0x00030005, 0x00040005, 0x00050005, 0x00060005,
    0x00070005, 0x00080005, 0x00090005, 0x000a0005, 0x000b0005, 0x000c0005, 0x000d0005, 0x000e0005,
    0x000f0005, 0x00000004, 0x00010004, 0x00020004, 0x00030004, 0x00040004, 0x00050004, 0x00060004,
    0x00070004, 0x00000003, 0x00010003, 0x00020003, 0x00030003, 0x00000002, 0x00010002, 0x00000001,
    0x00000000, 0x00010001, 0x00020002, 0x00030002, 0x00040003, 0x00050003, 0x00060003, 0x00070003,
    0x00080004, 0x00090004, 0x000a0004, 0x000b0004, 0x000c0004, 0x000d0004, 0x000e0004, 0x000f0004,
    0x00100005, 0x00110005, 0x00120005, 0x00130005, 0x00140005, 0x00150005, 0x00160005, 0x00170005,
    0x00180005, 0x00190005, 0x001a0005, 0x001b0005, 0x001c0005, 0x001d0005, 0x001e0005, 0x001f0005,
    0x00200006, 0x00210006, 0x00220006, 0x00230006, 0x00240006, 0x00250006, 0x00260006, 0x00270006,
    0x00280006, 0x00290006, 0x002a0006, 0x002b0006, 0x002c0006, 0x002d0006, 0x002e0006, 0x002f0006,
    0x00300006, 0x00310006, 0x00320006, 0x00330006, 0x00340006, 0x00350006, 0x00360006, 0x00370006,
    0x00380006, 0x00390006, 0x003a0006, 0x003b0006, 0x003c0006, 0x003d0006, 0x003e0006, 0x003f0006,
    0x00400007, 0x00410007, 0x00420007, 0x00430007, 0x00440007, 0x00450007, 0x00460007, 0x00470007,
    0x00480007, 0x00490007, 0x004a0007, 0x004b0007, 0x004c0007, 0x004d0007, 0x004e0007, 0x004f0007,
    0x00500007, 0x00510007, 0x00520007, 0x00530007, 0x00540007, 0x00550007, 0x00560007, 0x00570007,
    0x00580007, 0x00590007, 0x005a0007, 0x005b0007, 0x005c0007, 0x005d0007, 0x005e0007, 0x005f0007,
    0x00600007, 0x00610007, 0x00620007, 0x00630007, 0x00640007, 0x00650007, 0x00660007, 0x00670007,
    0x00680007, 0x00690007, 0x006a0007, 0x006b0007, 0x006c0007, 0x006d0007, 0x006e0007, 0x006f0007,
    0x00700007, 0x00710007, 0x00720007, 0x00730007, 0x00740007, 0x00750007, 0x00760007, 0x00770007,
    0x00780007, 0x00790007, 0x007a0007, 0x007b0007, 0x007c0007, 0x007d0007, 0x007e0007, 0x007f0007,
    0x00800008, 0x00810008, 0x00820008, 0x00830008, 0x00840008, 0x00850008, 0x00860008, 0x00870008,
    0x00880008, 0x00890008, 0x008a0008, 0x008b0008, 0x008c0008, 0x008d0008, 0x008e0008, 0x008f0008,
    0x00900008, 0x00910008, 0x00920008, 0x00930008, 0x00940008, 0x00950008, 0x00960008, 0x00970008,
    0x00980008, 0x00990008, 0x009a0008, 0x009b0008, 0x009c0008, 0x009d0008, 0x009e0008, 0x009f0008,
    0x00a00008, 0x00a10008, 0x00a20008, 0x00a30008, 0x00a40008, 0x00a50008, 0x00a60008, 0x00a70008,
    0x00a80008, 0x00a90008, 0x00aa0008, 0x00ab0008, 0x00ac0008, 0x00ad0008, 0x00ae0008, 0x00af0008,
    0x00b00008, 0x00b10008, 0x00b20008, 0x00b30008, 0x00b40008, 0x00b50008, 0x00b60008, 0x00b70008,
    0x00b80008, 0x00b90008, 0x00ba0008, 0x00bb0008, 0x00bc0008, 0x00bd0008, 0x00be0008, 0x00bf0008,
    0x00c00008, 0x00c10008, 0x00c20008, 0x00c30008, 0x00c40008, 0x00c50008, 0x00c60008, 0x00c70008,
    0x00c80008, 0x00c90008, 0x00ca0008, 0x00cb0008, 0x00cc0008, 0x00cd0008, 0x00ce0008, 0x00cf0008,
    0x00d00008, 0x00d10008, 0x00d20008, 0x00d30008, 0x00d40008, 0x00d50008, 0x00d60008, 0x00d70008,
    0x00d80008, 0x00d90008, 0x00da0008, 0x00db0008, 0x00dc0008, 0x00dd0008, 0x00de0008, 0x00df0008,
    0x00e00008, 0x00e10008, 0x00e20008, 0x00e30008, 0x00e40008, 0x00e50008, 0x00e60008, 0x00e70008,
    0x00e80008, 0x00e90008, 0x00ea0008, 0x00eb0008, 0x00ec0008, 0x00ed0008, 0x00ee0008, 0x00ef0008,
    0x00f00008, 0x00f10008, 0x00f20008, 0x00f30008, 0x00f40008, 0x00f50008, 0x00f60008, 0x00f70008,
    0x00f80008, 0x00f90008, 0x00fa0008, 0x00fb0008, 0x00fc0008, 0x00fd0008, 0x00fe0008, 0x00ff0008,
    0x01000009, 0x01010009, 0x01020009, 0x01030009, 0x01040009, 0x01050009, 0x01060009, 0x01070009,
    0x01080009, 0x01090009, 0x010a0009, 0x010b0009, 0x010c0009, 0x010d0009, 0x010e0009, 0x010f0009,
    0x01100009, 0x01110009, 0x01120009, 0x01130009, 0x01140009, 0x01150009, 0x01160009, 0x01170009,
    0x01180009, 0x01190009, 0x011a0009, 0x011b0009, 0x011c0009, 0x011d0009, 0x011e0009, 0x011f0009,
    0x01200009, 0x01210009, 0x01220009, 0x01230009, 0x01240009, 0x01250009, 0x01260009, 0x01270009,
    0x01280009, 0x01290009, 0x012a0009, 0x012b0009, 0x012c0009, 0x012d0009, 0x012e0009, 0x012f0009,
    0x01300009, 0x01310009, 0x01320009, 0x01330009, 0x01340009, 0x01350009, 0x01360009, 0x01370009,
    0x01380009, 0x01390009, 0x013a0009, 0x013b0009, 0x013c0009, 0x013d0009, 0x013e0009, 0x013f0009,
    0x01400009, 0x01410009, 0x01420009, 0x01430009, 0x01440009, 0x01450009, 0x01460009, 0x01470009,
    0x01480009, 0x01490009, 0x014a0009, 0x014b0009, 0x014c0009, 0x014d0009, 0x014e0009, 0x014f0009,
    0x01500009, 0x01510009, 0x01520009, 0x01530009, 0x01540009, 0x01550009, 0x01560009, 0x01570009,
    0x01580009, 0x01590009, 0x015a0009, 0x015b0009, 0x015c0009, 0x015d0009, 0x015e0009, 0x015f0009,
    0x01600009, 0x01610009, 0x01620009, 0x01630009, 0x01640009, 0x01650009, 0x01660009, 0x01670009,
    0x01680009, 0x01690009, 0x016a0009, 0x016b0009, 0x016c0009, 0x016d0009, 0x016e0009, 0x016f0009,
    0x01700009, 0x01710009, 0x01720009, 0x01730009, 0x01740009, 0x01750009, 0x01760009, 0x01770009,
    0x01780009, 0x01790009, 0x017a0009, 0x017b0009, 0x017c0009, 0x017d0009, 0x017e0009, 0x017f0009,
    0x01800009, 0x01810009, 0x01820009, 0x01830009, 0x01840009, 0x01850009, 0x01860009, 0x01870009,
    0x01880009, 0x01890009, 0x018a0009, 0x018b0009, 0x018c0009, 0x018d0009, 0x018e0009, 0x018f0009,
    0x01900009, 0x01910009, 0x01920009, 0x01930009, 0x01940009, 0x01950009, 0x01960009, 0x01970009,
    0x01980009, 0x01990009, 0x019a0009, 0x019b0009, 0x019c0009, 0x019d0009, 0x019e0009, 0x019f0009,
    0x01a00009, 0x01a10009, 0x01a20009, 0x01a30009, 0x01a40009, 0x01a50009, 0x01a60009, 0x01a70009,
    0x01a80009, 0x01a90009, 0x01aa0009, 0x01ab0009, 0x01ac0009, 0x01ad0009, 0x01ae0009, 0x01af0009,
    0x01b00009, 0x01b10009, 0x01b20009, 0x01b30009, 0x01b40009, 0x01b50009, 0x01b60009, 0x01b70009,
    0x01b80009, 0x01b90009, 0x01ba0009, 0x01bb0009, 0x01bc0009, 0x01bd0009, 0x01be0009, 0x01bf0009,
    0x01c00009, 0x01c10009, 0x01c20009, 0x01c30009, 0x01c40009, 0x01c50009, 0x01c60009, 0x01c70009,
    0x01c80009, 0x01c90009, 0x01ca0009, 0x01cb0009, 0x01cc0009, 0x01cd0009, 0x01ce0009, 0x01cf0009,
    0x01d00009, 0x01d10009, 0x01d20009, 0x01d30009, 0x01d40009, 0x01d50009, 0x01d60009, 0x01d70009,
    0x01d80009, 0x01d90009, 0x01da0009, 0x01db0009, 0x01dc0009, 0x01dd0009, 0x01de0009, 0x01df0009,
    0x01e00009, 0x01e10009, 0x01e20009, 0x01e30009, 0x01e40009, 0x01e50009, 0x01e60009, 0x01e70009,
    0x01e80009, 0x01e90009, 0x01ea0009, 0x01eb0009, 0x01ec0009, 0x01ed0009, 0x01ee0009, 0x01ef0009,
    0x01f00009, 0x01f10009, 0x01f20009, 0x01f30009, 0x01f40009, 0x01f50009, 0x01f60009, 0x01f70009,
    0x01f80009, 0x01f90009, 0x01fa0009, 0x01fb0009, 0x01fc0009, 0x01fd0009, 0x01fe0009, 0x01ff0009,
    0x0200000a, 0x0201000a, 0x0202000a, 0x0203000a, 0x0204000a, 0x0205000a, 0x0206000a, 0x0207000a,
    0x0208000a, 0x0209000a, 0x020a000a, 0x020b000a, 0x020c000a, 0x020d000a, 0x020e000a, 0x020f000a,
    0x0210000a, 0x0211000a, 0x0212000a, 0x0213000a, 0x0214000a, 0x0215000a, 0x0216000a, 0x0217000a,
    0x0218000a, 0x0219000a, 0x021a000a, 0x021b000a, 0x021c000a, 0x021d000a, 0x021e000a, 0x021f000a,
    0x0220000a, 0x0221000a, 0x0222000a, 0x0223000a, 0x0224000a, 0x0225000a, 0x0226000a, 0x0227000a,
    0x0228000a, 0x0229000a, 0x022a000a, 0x022b000a, 0x022c000a, 0x022d000a, 0x022e000a, 0x022f000a,
    0x0230000a, 0x0231000a, 0x0232000a, 0x0233000a, 0x0234000a, 0x0235000a, 0x0236000a, 0x0237000a,
    0x0238000a, 0x0239000a, 0x023a000a, 0x023b000a, 0x023c000a, 0x023d000a, 0x023e000a, 0x023f000a,
    0x0240000a, 0x0241000a, 0x0242000a, 0x0243000a, 0x0244000a, 0x0245000a, 0x0246000a, 0x0247000a,
    0x0248000a, 0x0249000a, 0x024a000a, 0x024b000a, 0x024c000a, 0x024d000a, 0x024e000a, 0x024f000a,
    0x0250000a, 0x0251000a, 0x0252000a, 0x0253000a, 0x0254000a, 0x0255000a, 0x0256000a, 0x0257000a,
    0x0258000a, 0x0259000a, 0x025a000a, 0x025b000a, 0x025c000a, 0x025d000a, 0x025e000a, 0x025f000a,
    0x0260000a, 0x0261000a, 0x0262000a, 0x0263000a, 0x0264000a, 0x0265000a, 0x0266000a, 0x0267000a,
    0x0268000a, 0x0269000a, 0x026a000a, 0x026b000a, 0x026c000a, 0x026d000a, 0x026e000a, 0x026f000a,
    0x0270000a, 0x0271000a, 0x0272000a, 0x0273000a, 0x0274000a, 0x0275000a, 0x0276000a, 0x0277000a,
    0x0278000a, 0x0279000a, 0x027a000a, 0x027b000a, 0x027c000a, 0x027d000a, 0x027e000a, 0x027f000a,
    0x0280000a, 0x0281000a, 0x0282000a, 0x0283000a, 0x0284000a, 0x0285000a, 0x0286000a, 0x0287000a,
    0x0288000a, 0x0289000a, 0x028a000a, 0x028b000a, 0x028c000a, 0x028d000a, 0x028e000a, 0x028f000a,
    0x0290000a, 0x0291000a, 0x0292000a, 0x0293000a, 0x0294000a, 0x0295000a, 0x0296000a, 0x0297000a,
    0x0298000a, 0x0299000a, 0x029a000a, 0x029b000a, 0x029c000a, 0x029d000a, 0x029e000a, 0x029f000a,
    0x02a0000a, 0x02a1000a, 0x02a2000a, 0x02a3000a, 0x02a4000a, 0x02a5000a, 0x02a6000a, 0x02a7000a,
    0x02a8000a, 0x02a9000a, 0x02aa000a, 0x02ab000a, 0x02ac000a, 0x02ad000a, 0x02ae000a, 0x02af000a,
    0x02b0000a, 0x02b1000a, 0x02b2000a, 0x02b3000a, 0x02b4000a, 0x02b5000a, 0x02b6000a, 0x02b7000a,
    0x02b8000a, 0x02b9000a, 0x02ba000a, 0x02bb000a, 0x02bc000a, 0x02bd000a, 0x02be000a, 0x02bf000a,
    0x02c0000a, 0x02c1000a, 0x02c2000a, 0x02c3000a, 0x02c4000a, 0x02c5000a, 0x02c6000a, 0x02c7000a,
    0x02c8000a, 0x02c9000a, 0x02ca000a, 0x02cb000a, 0x02cc000a, 0x02cd000a, 0x02ce000a, 0x02cf000a,
    0x02d0000a, 0x02d1000a, 0x02d2000a, 0x02d3000a, 0x02d4000a, 0x02d5000a, 0x02d6000a, 0x02d7000a,
    0x02d8000a, 0x02d9000a, 0x02da000a, 0x02db000a, 0x02dc000a, 0x02dd000a, 0x02de000a, 0x02df000a,
    0x02e0000a, 0x02e1000a, 0x02e2000a, 0x02e3000a, 0x02e4000a, 0x02e5000a, 0x02e6000a, 0x02e7000a,
    0x02e8000a, 0x02e9000a, 0x02ea000a, 0x02eb000a, 0x02ec000a, 0x02ed000a, 0x02ee000a, 0x02ef000a,
    0x02f0000a, 0x02f1000a, 0x02f2000a, 0x02f3000a, 0x02f4000a, 0x02f5000a, 0x02f6000a, 0x02f7000a,
    0x02f8000a, 0x02f9000a, 0x02fa000a, 0x02fb000a, 0x02fc000a, 0x02fd000a, 0x02fe000a, 0x02ff000a,
    0x0300000a, 0x0301000a, 0x0302000a, 0x0303000a, 0x0304000a, 0x0305000a, 0x0306000a, 0x0307000a,
    0x0308000a, 0x0309000a, 0x030a000a, 0x030b000a, 0x030c000a, 0x030d000a, 0x030e000a, 0x030f000a,
    0x0310000a, 0x0311000a, 0x0312000a, 0x0313000a, 0x0314000a, 0x0315000a, 0x0316000a, 0x0317000a,
    0x0318000a, 0x0319000a, 0x031a000a, 0x031b000a, 0x031c000a, 0x031d000a, 0x031e000a, 0x031f000a,
    0x0320000a, 0x0321000a, 0x0322000a, 0x0323000a, 0x0324000a, 0x0325000a, 0x0326000a, 0x0327000a,
    0x0328000a, 0x0329000a, 0x032a000a, 0x032b000a, 0x032c000a, 0x032d000a, 0x032e000a, 0x032f000a,
    0x0330000a, 0x0331000a, 0x0332000a, 0x0333000a, 0x0334000a, 0x0335000a, 0x0336000a, 0x0337000a,
    0x0338000a, 0x0339000a, 0x033a000a, 0x033b000a, 0x033c000a, 0x033d000a, 0x033e000a, 0x033f000a,
    0x0340000a, 0x0341000a, 0x0342000a, 0x0343000a, 0x0344000a, 0x0345000a, 0x0346000a, 0x0347000a,
    0x0348000a, 0x0349000a, 0x034a000a, 0x034b000a, 0x034c000a, 0x034d000a, 0x034e000a, 0x034f000a,
    0x0350000a, 0x0351000a, 0x0352000a, 0x0353000a, 0x0354000a, 0x0355000a, 0x0356000a, 0x0357000a,
    0x0358000a, 0x0359000a, 0x035a000a, 0x035b000a, 0x035c000a, 0x035d000a, 0x035e000a, 0x035f000a,
    0x0360000a, 0x0361000a, 0x0362000a, 0x0363000a, 0x0364000a, 0x0365000a, 0x0366000a, 0x0367000a,
    0x0368000a, 0x0369000a, 0x036a000a, 0x036b000a, 0x036c000a, 0x036d000a, 0x036e000a, 0x036f000a,
    0x0370000a, 0x0371000a, 0x0372000a, 0x0373000a, 0x0374000a, 0x0375000a, 0x0376000a, 0x0377000a,
    0x0378000a, 0x0379000a, 0x037a000a, 0x037b000a, 0x037c000a, 0x037d000a, 0x037e000a, 0x037f000a,
    0x0380000a, 0x0381000a, 0x0382000a, 0x0383000a, 0x0384000a, 0x0385000a, 0x0386000a, 0x0387000a,
    0x0388000a, 0x0389000a, 0x038a000a, 0x038b000a, 0x038c000a, 0x038d000a, 0x038e000a, 0x038f000a,
    0x0390000a, 0x0391000a, 0x0392000a, 0x0393000a, 0x0394000a, 0x0395000a, 0x0396000a, 0x0397000a,
    0x0398000a, 0x0399000a, 0x039a000a, 0x039b000a, 0x039c000a, 0x039d000a, 0x039e000a, 0x039f000a,
    0x03a0000a, 0x03a1000a, 0x03a2000a, 0x03a3000a, 0x03a4000a, 0x03a5000a, 0x03a6000a, 0x03a7000a,
    0x03a8000a, 0x03a9000a, 0x03aa000a, 0x03ab000a, 0x03ac000a, 0x03ad000a, 0x03ae000a, 0x03af000a,
    0x03b0000a, 0x03b1000a, 0x03b2000a, 0x03b3000a, 0x03b4000a, 0x03b5000a, 0x03b6000a, 0x03b7000a,
    0x03b8000a, 0x03b9000a, 0x03ba000a, 0x03bb000a, 0x03bc000a, 0x03bd000a, 0x03be000a, 0x03bf000a,
    0x03c0000a, 0x03c1000a, 0x03c2000a, 0x03c3000a, 0x03c4000a, 0x03c5000a, 0x03c6000a, 0x03c7000a,
    0x03c8000a, 0x03c9000a, 0x03ca000a, 0x03cb000a, 0x03cc000a, 0x03cd000a, 0x03ce000a, 0x03cf000a,
    0x03d0000a, 0x03d1000a, 0x03d2000a, 0x03d3000a, 0x03d4000a, 0x03d5000a, 0x03d6000a, 0x03d7000a,
    0x03d8000a, 0x03d9000a, 0x03da000a, 0x03db000a, 0x03dc000a, 0x03dd000a, 0x03de000a, 0x03df000a,
    0x03e0000a, 0x03e1000a, 0x03e2000a, 0x03e3000a, 0x03e4000a, 0x03e5000a, 0x03e6000a, 0x03e7000a,
    0x03e8000a, 0x03e9000a, 0x03ea000a, 0x03eb000a, 0x03ec000a, 0x03ed000a, 0x03ee000a, 0x03ef000a,
    0x03f0000a, 0x03f1000a, 0x03f2000a, 0x03f3000a, 0x03f4000a, 0x03f5000a, 0x03f6000a, 0x03f7000a,
    0x03f8000a, 0x03f9000a, 0x03fa000a, 0x03fb000a, 0x03fc000a, 0x03fd000a, 0x03fe000a, 0x03ff000a
};

void jpeg_get_mcu(image_t *src, int x_offset, int y_offset, int dx, int dy,
                  int8_t *Y0, int8_t *CB, int8_t *CR) {
    switch (src->pixfmt) {
        case PIXFORMAT_BINARY: {
            if ((dx != JPEG_MCU_W) || (dy != JPEG_MCU_H)) {
                // partial MCU, fill with 0's to start
                memset(Y0, 0, JPEG_444_GS_MCU_SIZE);
            }

            for (int y = y_offset, yy = y + dy; y < yy; y++) {
                uint32_t *rp = IMAGE_COMPUTE_BINARY_PIXEL_ROW_PTR(src, y);
                uint8_t pixels = rp[x_offset >> UINT32_T_SHIFT] >> (x_offset & UINT32_T_MASK);

                if (dx == JPEG_MCU_W) {
                    *((uint32_t *) Y0) = jpeg_expand[pixels & 0xf];
                    *(((uint32_t *) Y0) + 1) = jpeg_expand[pixels >> 4];
                } else if (dx >= 4) {
                    *((uint32_t *) Y0) = jpeg_expand[pixels & 0xf];

                    if (dx >= 6) {
                        *(((uint16_t *) Y0) + 2) = jpeg_expand[pixels >> 4];

                        if (dx & 1) {
                            Y0[6] = (pixels & 0x40) ? JPEG_BINARY_1 : JPEG_BINARY_0;
                        }
                    } else if (dx & 1) {
                        Y0[4] = (pixels & 0x10) ? JPEG_BINARY_1 : JPEG_BINARY_0;
                    }
                } else if (dx >= 2) {
                    *((uint16_t *) Y0) = jpeg_expand[pixels & 0x3];

                    if (dx & 1) {
                        Y0[2] = (pixels & 0x4) ? JPEG_BINARY_1 : JPEG_BINARY_0;
                    }
                } else {
                    *Y0 = (pixels & 0x1) ? JPEG_BINARY_1 : JPEG_BINARY_0;
                }

                Y0 += JPEG_MCU_W;
            }
            break;
        }
        case PIXFORMAT_GRAYSCALE: {
            if ((dx != JPEG_MCU_W) || (dy != JPEG_MCU_H)) {
                // partial MCU, fill with 0's to start
                memset(Y0, 0, JPEG_444_GS_MCU_SIZE);
            }

            for (int y = y_offset, yy = y + dy; y < yy; y++) {
                uint8_t *rp = IMAGE_COMPUTE_GRAYSCALE_PIXEL_ROW_PTR(src, y) + x_offset;

                #if (OMV_JPEG_CODEC_ENABLE == 0)
                if (dx == JPEG_MCU_W) {
                    *((uint32_t *) Y0) = *((uint32_t *) rp) ^ 0x80808080;
                    *(((uint32_t *) Y0) + 1) = *(((uint32_t *) rp) + 1) ^ 0x80808080;
                } else if (dx >= 4) {
                    *((uint32_t *) Y0) = *((uint32_t *) rp) ^ 0x80808080;

                    if (dx >= 6) {
                        *(((uint16_t *) Y0) + 2) = *(((uint16_t *) rp) + 2) ^ 0x8080;

                        if (dx & 1) {
                            Y0[6] = rp[6] ^ 0x80;
                        }
                    } else if (dx & 1) {
                        Y0[4] = rp[4] ^ 0x80;
                    }
                } else if (dx >= 2) {
                    *((uint16_t *) Y0) = *((uint16_t *) rp) ^ 0x8080;

                    if (dx & 1) {
                        Y0[2] = rp[2] ^ 0x80;
                    }
                } else{
                    *Y0 = *rp ^ 0x80;
                }
                #else
                if (dx == JPEG_MCU_W) {
                    *((uint32_t *) Y0) = *((uint32_t *) rp);
                    *(((uint32_t *) Y0) + 1) = *(((uint32_t *) rp) + 1);
                } else if (dx >= 4) {
                    *((uint32_t *) Y0) = *((uint32_t *) rp);

                    if (dx >= 6) {
                        *(((uint16_t *) Y0) + 2) = *(((uint16_t *) rp) + 2);

                        if (dx & 1) {
                            Y0[6] = rp[6];
                        }
                    } else if (dx & 1) {
                        Y0[4] = rp[4];
                    }
                } else if (dx >= 2) {
                    *((uint16_t *) Y0) = *((uint16_t *) rp);

                    if (dx & 1) {
                        Y0[2] = rp[2];
                    }
                } else{
                    *Y0 = *rp;
                }
                #endif

                Y0 += JPEG_MCU_W;
            }
            break;
        }
        case PIXFORMAT_RGB565: {
            if ((dx != JPEG_MCU_W) || (dy != JPEG_MCU_H)) {
                // partial MCU, fill with 0's to start
                memset(Y0, 0, JPEG_444_GS_MCU_SIZE);
                memset(CB, 0, JPEG_444_GS_MCU_SIZE);
                memset(CR, 0, JPEG_444_GS_MCU_SIZE);
            }

            for (int y = y_offset, yy = y + dy, index = 0; y < yy; y++) {
                uint32_t *rp = (uint32_t *) (IMAGE_COMPUTE_RGB565_PIXEL_ROW_PTR(src, y) + x_offset);

                for (int x = 0, xx = dx - 1; x < xx; x += 2, index += 2) {
                    int pixels = *rp++;
                    int r_pixels = ((pixels >> 8) & 0xf800f8) | ((pixels >> 13) & 0x70007);
                    int g_pixels = ((pixels >> 3) & 0xfc00fc) | ((pixels >> 9) & 0x30003);
                    int b_pixels = ((pixels << 3) & 0xf800f8) | ((pixels >> 2) & 0x70007);

                    int y = ((r_pixels * 38) + (g_pixels * 75) + (b_pixels * 15)) >> 7;

                    #if (OMV_JPEG_CODEC_ENABLE == 0)
                    y ^= 0x800080;
                    #endif

                    Y0[index] = y, Y0[index + 1] = y >> 16;

                    int u = __SSUB16(b_pixels * 64, (r_pixels * 21) + (g_pixels * 43)) >> 7;

                    #if (OMV_JPEG_CODEC_ENABLE == 1)
                    u ^= 0x800080;
                    #endif

                    CB[index] = u, CB[index + 1] = u >> 16;

                    int v = __SSUB16(r_pixels * 64, (g_pixels * 54) + (b_pixels * 10)) >> 7;

                    #if (OMV_JPEG_CODEC_ENABLE == 1)
                    v ^= 0x800080;
                    #endif

                    CR[index] = v, CR[index + 1] = v >> 16;
                }

                if (dx & 1) {
                    int pixel = *((uint16_t *) rp);
                    int r = COLOR_RGB565_TO_R8(pixel);
                    int g = COLOR_RGB565_TO_G8(pixel);
                    int b = COLOR_RGB565_TO_B8(pixel);

                    int y0 = COLOR_RGB888_TO_Y(r, g, b);

                    #if (OMV_JPEG_CODEC_ENABLE == 0)
                    y0 ^= 0x80;
                    #endif

                    Y0[index] = y0;

                    int cb = COLOR_RGB888_TO_U(r, g, b);

                    #if (OMV_JPEG_CODEC_ENABLE == 1)
                    cb ^= 0x80;
                    #endif

                    CB[index] = cb;

                    int cr = COLOR_RGB888_TO_V(r, g, b);

                    #if (OMV_JPEG_CODEC_ENABLE == 1)
                    cr ^= 0x80;
                    #endif

                    CR[index++] = cr;
                }

                index += JPEG_MCU_W - dx;
            }
            break;
        }
        case PIXFORMAT_YUV_ANY: {
            if ((dx != JPEG_MCU_W) || (dy != JPEG_MCU_H)) {
                // partial MCU, fill with 0's to start
                memset(Y0, 0, JPEG_444_GS_MCU_SIZE);
                memset(CB, 0, JPEG_444_GS_MCU_SIZE);
                memset(CR, 0, JPEG_444_GS_MCU_SIZE);
            }

            int shift = (src->pixfmt == PIXFORMAT_YUV422) ? 24 : 8;

            for (int y = y_offset, yy = y + dy, index = 0; y < yy; y++) {
                uint32_t *rp = (uint32_t *) (IMAGE_COMPUTE_YUV_PIXEL_ROW_PTR(src, y) + x_offset);

                for (int x = 0, xx = dx - 1; x < xx; x += 2, index += 2) {
                    int pixels = *rp++;

                    #if (OMV_JPEG_CODEC_ENABLE == 0)
                    pixels ^= 0x80808080;
                    #endif

                    Y0[index] = pixels, Y0[index + 1] = pixels >> 16;

                    int cb = pixels >> shift;
                    CB[index] = cb, CB[index + 1] = cb;

                    int cr = pixels >> (32 - shift);
                    CR[index] = cr, CR[index + 1] = cr;
                }

                if (dx & 1) {
                    int pixel = *((uint16_t *) rp);

                    #if (OMV_JPEG_CODEC_ENABLE == 0)
                    pixel ^= 0x8080;
                    #endif

                    Y0[index] = pixel;

                    if (index % JPEG_MCU_W) {
                        if (shift == 8) {
                            CR[index] = CR[index - 1];
                            CB[index++] = pixel >> 8;
                        } else {
                            CB[index] = CB[index - 1];
                            CR[index++] = pixel >> 8;
                        }
                    } else {
                        if (shift == 8) {
                            CB[index] = pixel >> 8;
                            #if (OMV_JPEG_CODEC_ENABLE == 0)
                            CR[index++] = 0;
                            #else
                            CR[index++] = 0x80;
                            #endif
                        } else {
                            #if (OMV_JPEG_CODEC_ENABLE == 0)
                            CB[index] = 0;
                            #else
                            CB[index] = 0x80;
                            #endif
                            CR[index++] = pixel >> 8;
                        }
                    }
                }

                index += JPEG_MCU_W - dx;
            }
            break;
        }
        case PIXFORMAT_BAYER_ANY: {
            if ((dx != JPEG_MCU_W) || (dy != JPEG_MCU_H)) {
                // partial MCU, fill with 0's to start
                memset(Y0, 0, JPEG_444_GS_MCU_SIZE);
                memset(CB, 0, JPEG_444_GS_MCU_SIZE);
                memset(CR, 0, JPEG_444_GS_MCU_SIZE);
            }

            rectangle_t roi = {
                .x = x_offset,
                .y = y_offset,
                .w = dx,
                .h = dy
            };

            imlib_debayer_ycbcr(src, &roi, Y0, CB, CR);
            break;
        }
    }
}

#if (OMV_JPEG_CODEC_ENABLE == 0)

// Software JPEG implementation.
#define FIX_0_382683433    ((int32_t) 98)
#define FIX_0_541196100    ((int32_t) 139)
#define FIX_0_707106781    ((int32_t) 181)
#define FIX_1_306562965    ((int32_t) 334)

#define DESCALE(x, y)      (x >> y)
#define MULTIPLY(x, y)     DESCALE((x) * (y), 8)

typedef struct {
    int idx;
    int length;
    uint8_t *buf;
    uint32_t bitb;
    uint32_t bitc;
    bool realloc;
    bool overflow;
} jpeg_buf_t;

// Quantization tables
static float fdtbl_Y[64], fdtbl_UV[64];
static uint8_t YTable[64], UVTable[64];

static const uint8_t s_jpeg_ZigZag[] = {
    0,  1,   5,  6, 14, 15, 27, 28,
    2,  4,   7, 13, 16, 26, 29, 42,
    3,  8,  12, 17, 25, 30, 41, 43,
    9,  11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54,
    20, 22, 33, 38, 46, 51, 55, 60,
    21, 34, 37, 47, 50, 56, 59, 61,
    35, 36, 48, 49, 57, 58, 62, 63
};

static const uint8_t s_jpeg_ZigZag2[64] = {
    0,   1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4,  5,
    12, 19, 26, 33, 40, 48, 41, 34,
    27, 20, 13,  6,  7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36,
    29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63
};

static const uint8_t YQT[] = {
    16, 11, 10, 16, 24,  40,  51,  61,
    12, 12, 14, 19, 26,  58,  60,  55,
    14, 13, 16, 24, 40,  57,  69,  56,
    14, 17, 22, 29, 51,  87,  80,  62,
    18, 22, 37, 56, 68,  109, 103, 77,
    24, 35, 55, 64, 81,  104, 113, 92,
    49, 64, 78, 87, 103, 121, 120, 101,
    72, 92, 95, 98, 112, 100, 103, 99
};

static const uint8_t UVQT[] = {
    17, 18, 24, 47, 99, 99, 99, 99,
    18, 21, 26, 66, 99, 99, 99, 99,
    24, 26, 56, 99, 99, 99, 99, 99,
    47, 66, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99
};

static const float aasf[] = {
    1.0f, 1.387039845f, 1.306562965f, 1.175875602f,
    1.0f, 0.785694958f, 0.541196100f, 0.275899379f
};


static const uint8_t std_dc_luminance_nrcodes[] = {0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};
static const uint8_t std_dc_luminance_values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
static const uint8_t std_ac_luminance_nrcodes[] = {0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d};
static const uint8_t std_ac_luminance_values[] = {
    0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,
    0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1,
    0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,
    0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25,
    0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
    0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
    0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1,
    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
};

static const uint8_t std_dc_chrominance_nrcodes[] = {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};
static const uint8_t std_dc_chrominance_values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
static const uint8_t std_ac_chrominance_nrcodes[] = {0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77};
static const uint8_t std_ac_chrominance_values[] = {
    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1,
    0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1,
    0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18,
    0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
    0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a,
    0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
    0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
    0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
    0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
};

// Huffman tables
static const uint16_t YDC_HT[12][2] = {
    {0, 2}, {2, 3}, {3, 3}, {4, 3},
    {5, 3}, {6, 3}, {14, 4}, {30, 5},
    {62, 6}, {126, 7}, {254, 8}, {510, 9},
};

static const uint16_t UVDC_HT[12][2] = {
    {0, 2}, {1, 2}, {2, 2}, {6, 3},
    {14, 4}, {30, 5}, {62, 6}, {126, 7},
    {254, 8}, {510, 9}, {1022, 10}, {2046, 11},
};

static const uint16_t YAC_HT[256][2] = {
    {0x000A, 0x0004}, {0x0000, 0x0002}, {0x0001, 0x0002}, {0x0004, 0x0003},
    {0x000B, 0x0004}, {0x001A, 0x0005}, {0x0078, 0x0007}, {0x00F8, 0x0008},
    {0x03F6, 0x000A}, {0xFF82, 0x0010}, {0xFF83, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x000C, 0x0004}, {0x001B, 0x0005}, {0x0079, 0x0007},
    {0x01F6, 0x0009}, {0x07F6, 0x000B}, {0xFF84, 0x0010}, {0xFF85, 0x0010},
    {0xFF86, 0x0010}, {0xFF87, 0x0010}, {0xFF88, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x001C, 0x0005}, {0x00F9, 0x0008}, {0x03F7, 0x000A},
    {0x0FF4, 0x000C}, {0xFF89, 0x0010}, {0xFF8A, 0x0010}, {0xFF8B, 0x0010},
    {0xFF8C, 0x0010}, {0xFF8D, 0x0010}, {0xFF8E, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x003A, 0x0006}, {0x01F7, 0x0009}, {0x0FF5, 0x000C},
    {0xFF8F, 0x0010}, {0xFF90, 0x0010}, {0xFF91, 0x0010}, {0xFF92, 0x0010},
    {0xFF93, 0x0010}, {0xFF94, 0x0010}, {0xFF95, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x003B, 0x0006}, {0x03F8, 0x000A}, {0xFF96, 0x0010},
    {0xFF97, 0x0010}, {0xFF98, 0x0010}, {0xFF99, 0x0010}, {0xFF9A, 0x0010},
    {0xFF9B, 0x0010}, {0xFF9C, 0x0010}, {0xFF9D, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x007A, 0x0007}, {0x07F7, 0x000B}, {0xFF9E, 0x0010},
    {0xFF9F, 0x0010}, {0xFFA0, 0x0010}, {0xFFA1, 0x0010}, {0xFFA2, 0x0010},
    {0xFFA3, 0x0010}, {0xFFA4, 0x0010}, {0xFFA5, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x007B, 0x0007}, {0x0FF6, 0x000C}, {0xFFA6, 0x0010},
    {0xFFA7, 0x0010}, {0xFFA8, 0x0010}, {0xFFA9, 0x0010}, {0xFFAA, 0x0010},
    {0xFFAB, 0x0010}, {0xFFAC, 0x0010}, {0xFFAD, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x00FA, 0x0008}, {0x0FF7, 0x000C}, {0xFFAE, 0x0010},
    {0xFFAF, 0x0010}, {0xFFB0, 0x0010}, {0xFFB1, 0x0010}, {0xFFB2, 0x0010},
    {0xFFB3, 0x0010}, {0xFFB4, 0x0010}, {0xFFB5, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01F8, 0x0009}, {0x7FC0, 0x000F}, {0xFFB6, 0x0010},
    {0xFFB7, 0x0010}, {0xFFB8, 0x0010}, {0xFFB9, 0x0010}, {0xFFBA, 0x0010},
    {0xFFBB, 0x0010}, {0xFFBC, 0x0010}, {0xFFBD, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01F9, 0x0009}, {0xFFBE, 0x0010}, {0xFFBF, 0x0010},
    {0xFFC0, 0x0010}, {0xFFC1, 0x0010}, {0xFFC2, 0x0010}, {0xFFC3, 0x0010},
    {0xFFC4, 0x0010}, {0xFFC5, 0x0010}, {0xFFC6, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01FA, 0x0009}, {0xFFC7, 0x0010}, {0xFFC8, 0x0010},
    {0xFFC9, 0x0010}, {0xFFCA, 0x0010}, {0xFFCB, 0x0010}, {0xFFCC, 0x0010},
    {0xFFCD, 0x0010}, {0xFFCE, 0x0010}, {0xFFCF, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x03F9, 0x000A}, {0xFFD0, 0x0010}, {0xFFD1, 0x0010},
    {0xFFD2, 0x0010}, {0xFFD3, 0x0010}, {0xFFD4, 0x0010}, {0xFFD5, 0x0010},
    {0xFFD6, 0x0010}, {0xFFD7, 0x0010}, {0xFFD8, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x03FA, 0x000A}, {0xFFD9, 0x0010}, {0xFFDA, 0x0010},
    {0xFFDB, 0x0010}, {0xFFDC, 0x0010}, {0xFFDD, 0x0010}, {0xFFDE, 0x0010},
    {0xFFDF, 0x0010}, {0xFFE0, 0x0010}, {0xFFE1, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x07F8, 0x000B}, {0xFFE2, 0x0010}, {0xFFE3, 0x0010},
    {0xFFE4, 0x0010}, {0xFFE5, 0x0010}, {0xFFE6, 0x0010}, {0xFFE7, 0x0010},
    {0xFFE8, 0x0010}, {0xFFE9, 0x0010}, {0xFFEA, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0xFFEB, 0x0010}, {0xFFEC, 0x0010}, {0xFFED, 0x0010},
    {0xFFEE, 0x0010}, {0xFFEF, 0x0010}, {0xFFF0, 0x0010}, {0xFFF1, 0x0010},
    {0xFFF2, 0x0010}, {0xFFF3, 0x0010}, {0xFFF4, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x07F9, 0x000B}, {0xFFF5, 0x0010}, {0xFFF6, 0x0010}, {0xFFF7, 0x0010},
    {0xFFF8, 0x0010}, {0xFFF9, 0x0010}, {0xFFFA, 0x0010}, {0xFFFB, 0x0010},
    {0xFFFC, 0x0010}, {0xFFFD, 0x0010}, {0xFFFE, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
};

static const uint16_t UVAC_HT[256][2] = {
    {0x0000, 0x0002}, {0x0001, 0x0002}, {0x0004, 0x0003}, {0x000A, 0x0004},
    {0x0018, 0x0005}, {0x0019, 0x0005}, {0x0038, 0x0006}, {0x0078, 0x0007},
    {0x01F4, 0x0009}, {0x03F6, 0x000A}, {0x0FF4, 0x000C}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x000B, 0x0004}, {0x0039, 0x0006}, {0x00F6, 0x0008},
    {0x01F5, 0x0009}, {0x07F6, 0x000B}, {0x0FF5, 0x000C}, {0xFF88, 0x0010},
    {0xFF89, 0x0010}, {0xFF8A, 0x0010}, {0xFF8B, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x001A, 0x0005}, {0x00F7, 0x0008}, {0x03F7, 0x000A},
    {0x0FF6, 0x000C}, {0x7FC2, 0x000F}, {0xFF8C, 0x0010}, {0xFF8D, 0x0010},
    {0xFF8E, 0x0010}, {0xFF8F, 0x0010}, {0xFF90, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x001B, 0x0005}, {0x00F8, 0x0008}, {0x03F8, 0x000A},
    {0x0FF7, 0x000C}, {0xFF91, 0x0010}, {0xFF92, 0x0010}, {0xFF93, 0x0010},
    {0xFF94, 0x0010}, {0xFF95, 0x0010}, {0xFF96, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x003A, 0x0006}, {0x01F6, 0x0009}, {0xFF97, 0x0010},
    {0xFF98, 0x0010}, {0xFF99, 0x0010}, {0xFF9A, 0x0010}, {0xFF9B, 0x0010},
    {0xFF9C, 0x0010}, {0xFF9D, 0x0010}, {0xFF9E, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x003B, 0x0006}, {0x03F9, 0x000A}, {0xFF9F, 0x0010},
    {0xFFA0, 0x0010}, {0xFFA1, 0x0010}, {0xFFA2, 0x0010}, {0xFFA3, 0x0010},
    {0xFFA4, 0x0010}, {0xFFA5, 0x0010}, {0xFFA6, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0079, 0x0007}, {0x07F7, 0x000B}, {0xFFA7, 0x0010},
    {0xFFA8, 0x0010}, {0xFFA9, 0x0010}, {0xFFAA, 0x0010}, {0xFFAB, 0x0010},
    {0xFFAC, 0x0010}, {0xFFAD, 0x0010}, {0xFFAE, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x007A, 0x0007}, {0x07F8, 0x000B}, {0xFFAF, 0x0010},
    {0xFFB0, 0x0010}, {0xFFB1, 0x0010}, {0xFFB2, 0x0010}, {0xFFB3, 0x0010},
    {0xFFB4, 0x0010}, {0xFFB5, 0x0010}, {0xFFB6, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x00F9, 0x0008}, {0xFFB7, 0x0010}, {0xFFB8, 0x0010},
    {0xFFB9, 0x0010}, {0xFFBA, 0x0010}, {0xFFBB, 0x0010}, {0xFFBC, 0x0010},
    {0xFFBD, 0x0010}, {0xFFBE, 0x0010}, {0xFFBF, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01F7, 0x0009}, {0xFFC0, 0x0010}, {0xFFC1, 0x0010},
    {0xFFC2, 0x0010}, {0xFFC3, 0x0010}, {0xFFC4, 0x0010}, {0xFFC5, 0x0010},
    {0xFFC6, 0x0010}, {0xFFC7, 0x0010}, {0xFFC8, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01F8, 0x0009}, {0xFFC9, 0x0010}, {0xFFCA, 0x0010},
    {0xFFCB, 0x0010}, {0xFFCC, 0x0010}, {0xFFCD, 0x0010}, {0xFFCE, 0x0010},
    {0xFFCF, 0x0010}, {0xFFD0, 0x0010}, {0xFFD1, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01F9, 0x0009}, {0xFFD2, 0x0010}, {0xFFD3, 0x0010},
    {0xFFD4, 0x0010}, {0xFFD5, 0x0010}, {0xFFD6, 0x0010}, {0xFFD7, 0x0010},
    {0xFFD8, 0x0010}, {0xFFD9, 0x0010}, {0xFFDA, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x01FA, 0x0009}, {0xFFDB, 0x0010}, {0xFFDC, 0x0010},
    {0xFFDD, 0x0010}, {0xFFDE, 0x0010}, {0xFFDF, 0x0010}, {0xFFE0, 0x0010},
    {0xFFE1, 0x0010}, {0xFFE2, 0x0010}, {0xFFE3, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x07F9, 0x000B}, {0xFFE4, 0x0010}, {0xFFE5, 0x0010},
    {0xFFE6, 0x0010}, {0xFFE7, 0x0010}, {0xFFE8, 0x0010}, {0xFFE9, 0x0010},
    {0xFFEA, 0x0010}, {0xFFEB, 0x0010}, {0xFFEC, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x3FE0, 0x000E}, {0xFFED, 0x0010}, {0xFFEE, 0x0010},
    {0xFFEF, 0x0010}, {0xFFF0, 0x0010}, {0xFFF1, 0x0010}, {0xFFF2, 0x0010},
    {0xFFF3, 0x0010}, {0xFFF4, 0x0010}, {0xFFF5, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
    {0x03FA, 0x000A}, {0x7FC3, 0x000F}, {0xFFF6, 0x0010}, {0xFFF7, 0x0010},
    {0xFFF8, 0x0010}, {0xFFF9, 0x0010}, {0xFFFA, 0x0010}, {0xFFFB, 0x0010},
    {0xFFFC, 0x0010}, {0xFFFD, 0x0010}, {0xFFFE, 0x0010}, {0x0000, 0x0000},
    {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000}, {0x0000, 0x0000},
};

// Check if the output buffer is nearly full and allocate more space
// if needed. If realloc is disabled, return true to halt the encoding.
static int jpeg_check_highwater(jpeg_buf_t *jpeg_buf) {
    if ((jpeg_buf->idx + 1) >= jpeg_buf->length - 256) {
        if (jpeg_buf->realloc == false) {
            // Can't realloc buffer
            jpeg_buf->overflow = true;
            return 1;
        }
        jpeg_buf->length += 1024;
        jpeg_buf->buf = xrealloc(jpeg_buf->buf, jpeg_buf->length);
    }
    return 0;
}

static void jpeg_put_char(jpeg_buf_t *jpeg_buf, char c) {
    if ((jpeg_buf->idx + 1) >= jpeg_buf->length) {
        if (jpeg_buf->realloc == false) {
            // Can't realloc buffer
            jpeg_buf->overflow = true;
            return;
        }
        jpeg_buf->length += 1024;
        jpeg_buf->buf = xrealloc(jpeg_buf->buf, jpeg_buf->length);
    }

    jpeg_buf->buf[jpeg_buf->idx++] = c;
}

static void jpeg_put_bytes(jpeg_buf_t *jpeg_buf, const void *data, int size) {
    if ((jpeg_buf->idx + size) >= jpeg_buf->length) {
        if (jpeg_buf->realloc == false) {
            // Can't realloc buffer
            jpeg_buf->overflow = true;
            return;
        }
        jpeg_buf->length += 1024;
        jpeg_buf->buf = xrealloc(jpeg_buf->buf, jpeg_buf->length);
    }

    memcpy(jpeg_buf->buf + jpeg_buf->idx, data, size);
    jpeg_buf->idx += size;
}

static inline void jpeg_write_bits(jpeg_buf_t *jpeg_buf, const uint16_t *bs) {
    jpeg_buf->bitc += bs[1];
    jpeg_buf->bitb |= bs[0] << (24 - jpeg_buf->bitc);

    while (jpeg_buf->bitc > 7) {
        uint8_t c = (jpeg_buf->bitb >> 16) & 255;
        jpeg_put_char(jpeg_buf, c);
        if (c == 255) {
            jpeg_put_char(jpeg_buf, 0);
        }
        jpeg_buf->bitb <<= 8;
        jpeg_buf->bitc -= 8;
    }
}

#define STORECODE(ulCode, iNewLen)                                    \
    u32bc += iNewLen; u32bb |= (ulCode << (32 - u32bc));              \
    while (u32bc >= 8) {                                              \
        unsigned char c = (unsigned char) (u32bb >> 24); *pOut++ = c; \
        if (c == 0xff) { *pOut++ = 0;}                                \
        u32bb <<= 8; u32bc -= 8; }                                    \

static int jpeg_processDU(jpeg_buf_t *jpeg_buf, int8_t *CDU, float *fdtbl, int DC, const uint16_t (*HTDC)[2],
                          const uint16_t (*HTAC)[2]) {
    int DU[64];
    int z1, z2, z3, z4, z5, z11, z13;
    int t0, t1, t2, t3, t4, t5, t6, t7, t10, t11, t12, t13;
    const uint16_t EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };
    const uint16_t M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };
    uint32_t u32bb, u32bc; // bit buffer and bit count for output data stream
    uint8_t *pOut; // output data pointer
    uint32_t ulMagVal, ulCode;
    int i, iLen, *p;
    const uint32_t *pMagFix = &ulMagnitudeFix[1024]; // allows indexing positive and negative values - speeds up total encode time by 15%
    uint8_t cMagnitude;
    float *pfd;

    if (jpeg_check_highwater(jpeg_buf)) {
        // check if we're getting close to the end of the buffer
        return 0; // stop encoding, we've run out of space
    }
    // Use local copies to speed up access
    pOut = &jpeg_buf->buf[jpeg_buf->idx];
    u32bb = jpeg_buf->bitb;
    u32bc = jpeg_buf->bitc;

    // DCT rows
    for (i = 8, p = DU; i > 0; i--, p += 8, CDU += 8) {
        t0 = CDU[0] + CDU[7];
        t1 = CDU[1] + CDU[6];
        t2 = CDU[2] + CDU[5];
        t3 = CDU[3] + CDU[4];

        t7 = CDU[0] - CDU[7];
        t6 = CDU[1] - CDU[6];
        t5 = CDU[2] - CDU[5];
        t4 = CDU[3] - CDU[4];

        // Even part
        t10 = t0 + t3;
        t13 = t0 - t3;
        t11 = t1 + t2;
        t12 = t1 - t2;
        z1 = MULTIPLY(t12 + t13, FIX_0_707106781); // c4

        p[0] = t10 + t11;
        p[4] = t10 - t11;
        p[2] = t13 + z1;
        p[6] = t13 - z1;

        // Odd part
        t10 = t4 + t5;// phase 2
        t11 = t5 + t6;
        t12 = t6 + t7;

        // The rotator is modified from fig 4-8 to avoid extra negations.
        z5 = MULTIPLY(t10 - t12, FIX_0_382683433); // c6
        z2 = MULTIPLY(t10, FIX_0_541196100) + z5; // 1.306562965f-c6
        z4 = MULTIPLY(t12, FIX_1_306562965) + z5; // 1.306562965f+c6
        z3 = MULTIPLY(t11, FIX_0_707106781); // c4
        z11 = t7 + z3;    // phase 5
        z13 = t7 - z3;

        p[5] = z13 + z2;// phase 6
        p[3] = z13 - z2;
        p[1] = z11 + z4;
        p[7] = z11 - z4;
    }

    // DCT columns
    for (i = 8, p = DU, pfd = fdtbl; i > 0; i--, p++, pfd++) {
        t0 = p[0] + p[56];
        t1 = p[8] + p[48];
        t2 = p[16] + p[40];
        t3 = p[24] + p[32];

        t7 = p[0] - p[56];
        t6 = p[8] - p[48];
        t5 = p[16] - p[40];
        t4 = p[24] - p[32];

        // Even part
        t10 = t0 + t3;  // phase 2
        t13 = t0 - t3;
        t11 = t1 + t2;
        t12 = t1 - t2;
        z1 = MULTIPLY(t12 + t13, FIX_0_707106781); // c4

        p[0] = fast_roundf((t10 + t11) * pfd[0]);               // phase 3
        p[32] = fast_roundf((t10 - t11) * pfd[32]);
        p[16] = fast_roundf((t13 + z1) * pfd[16]);               // phase 5
        p[48] = fast_roundf((t13 - z1) * pfd[48]);

        // Odd part
        t10 = t4 + t5;          // phase 2
        t11 = t5 + t6;
        t12 = t6 + t7;

        // The rotator is modified from fig 4-8 to avoid extra negations.
        z5 = MULTIPLY(t10 - t12, FIX_0_382683433); // c6
        z2 = MULTIPLY(t10, FIX_0_541196100) + z5; // 1.306562965f-c6
        z4 = MULTIPLY(t12, FIX_1_306562965) + z5; // 1.306562965f+c6
        z3 = MULTIPLY(t11, FIX_0_707106781); // c4
        z11 = t7 + z3;          // phase 5
        z13 = t7 - z3;

        p[40] = fast_roundf((z13 + z2) * pfd[40]);// phase 6
        p[24] = fast_roundf((z13 - z2) * pfd[24]);
        p[8] = fast_roundf((z11 + z4) * pfd[8]);
        p[56] = fast_roundf((z11 - z4) * pfd[56]);
    }

    // Encode DC
    int diff = DU[0] - DC;
    if (diff == 0) {
        STORECODE(HTDC[0][0], HTDC[0][1])
    } else {
        ulMagVal = pMagFix[diff]; // get magnitude and new delta in one table read
        diff = (ulMagVal >> 16);
        cMagnitude = ulMagVal & 0xf;
        ulCode = HTDC[cMagnitude][0];
        iLen = HTDC[cMagnitude][1];
        ulCode = (ulCode << cMagnitude) | diff;
        iLen += cMagnitude;
        STORECODE(ulCode, iLen)
    }

    // Encode ACs
    uint8_t *pZig, *pZigEnd, *pZigStart;
    int nrzeroes;
    pZig = (uint8_t *) &s_jpeg_ZigZag2[1];
    pZigEnd = (uint8_t *) &s_jpeg_ZigZag2[64];
    while (pZig < pZigEnd) {
        pZigStart = pZig;
        while (pZig < pZigEnd && (diff = DU[pZig[0]]) == 0) {
            pZig++;
        }
        if (pZig == pZigEnd) {
            STORECODE(EOB[0], EOB[1])
        } else {
            nrzeroes = (int) (pZig - pZigStart);
            while (nrzeroes >= 16) {
                STORECODE(M16zeroes[0], M16zeroes[1])
                nrzeroes -= 16;
            }
            ulMagVal = pMagFix[diff];
            diff = (ulMagVal >> 16);
            cMagnitude = ulMagVal & 0xf;
            ulCode = HTAC[(nrzeroes << 4) | cMagnitude][0];
            iLen = HTAC[(nrzeroes << 4) | cMagnitude][1];
            ulCode = (ulCode << cMagnitude) | diff; // combine into one code
            pZig++; // next coefficient
            iLen += cMagnitude;
            STORECODE(ulCode, iLen)
        }
    } // while (pZig < pZigEnd)
    // Restore the 'bits' structure values
    jpeg_buf->idx = (int) (pOut - jpeg_buf->buf);
    jpeg_buf->bitb = u32bb;
    jpeg_buf->bitc = u32bc;

    return DU[0];
}

static void jpeg_init(int quality) {
    static int q = 0;

    quality = quality < 50 ? 5000 / quality : 200 - quality * 2;

    // If quality changed, update quantization matrix
    if (q != quality) {
        q = quality;
        for (int i = 0; i < 64; ++i) {
            int yti = (YQT[i] * quality + 50) / 100;
            YTable[s_jpeg_ZigZag[i]] = yti < 1 ? 1 : yti > 255 ? 255 : yti;
            int uvti = (UVQT[i] * quality + 50) / 100;
            UVTable[s_jpeg_ZigZag[i]] = uvti < 1 ? 1 : uvti > 255 ? 255 : uvti;
        }

        for (int r = 0, k = 0; r < 8; ++r) {
            for (int c = 0; c < 8; ++c, ++k) {
                fdtbl_Y[k] = 1.0f / (aasf[r] * aasf[c] * YTable [s_jpeg_ZigZag[k]] * 8.0f);
                fdtbl_UV[k] = 1.0f / (aasf[r] * aasf[c] * UVTable[s_jpeg_ZigZag[k]] * 8.0f);
            }
        }
    }
}

static void jpeg_write_headers(jpeg_buf_t *jpeg_buf, int w, int h, int bpp, jpeg_subsampling_t subsampling) {
    // Number of components (1 or 3)
    uint8_t nr_comp = (bpp == 1)? 1 : 3;

    // JPEG headers
    uint8_t m_soi[] = {
        0xFF, 0xD8          // SOI
    };

    uint8_t m_app0[] = {
        0xFF, 0xE0,         // APP0
        0x00, 0x10,  'J',  'F',  'I',  'F', 0x00, 0x01,
        0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00
    };

    uint8_t m_dqt[] = {
        0xFF, 0xDB,         // DQT
        (bpp * 65 + 2) >> 8,      // Header length MSB
        (bpp * 65 + 2) & 0xFF,    // Header length LSB
    };

    uint8_t m_sof0[] = {
        0xFF, 0xC0,         // SOF0
        (nr_comp * 3 + 8) >> 8,   // Header length MSB
        (nr_comp * 3 + 8) & 0xFF, // Header length LSB
        0x08,               // Bits per sample
        h >> 8, h & 0xFF,       // Height
        w >> 8, w & 0xFF,       // Width
        nr_comp,            // Number of components
    };

    uint8_t m_dht[] = {
        0xFF, 0xC4,         // DHT
        (bpp * 208 + 2) >> 8,     // Header length MSB
        (bpp * 208 + 2) & 0xFF,   // Header length LSB
    };

    uint8_t m_sos[] = {
        0xFF, 0xDA,         // SOS
        (nr_comp * 2 + 6) >> 8,   // Header length MSB
        (nr_comp * 2 + 6) & 0xFF, // Header length LSB
        nr_comp,            // Number of components
    };

    // Write SOI marker
    jpeg_put_bytes(jpeg_buf, m_soi, sizeof(m_soi));
    // Write APP0 marker
    jpeg_put_bytes(jpeg_buf, m_app0, sizeof(m_app0));

    // Write DQT marker
    jpeg_put_bytes(jpeg_buf, m_dqt, sizeof(m_dqt));
    // Write Y quantization table (index, table)
    jpeg_put_char(jpeg_buf, 0);
    jpeg_put_bytes(jpeg_buf, YTable, sizeof(YTable));

    if (bpp > 1) {
        // Write UV quantization table (index, table)
        jpeg_put_char(jpeg_buf, 1);
        jpeg_put_bytes(jpeg_buf, UVTable, sizeof(UVTable));
    }

    // Write SOF0 marker
    jpeg_put_bytes(jpeg_buf, m_sof0, sizeof(m_sof0));
    for (int i = 0; i < nr_comp; i++) {
        // Component ID, HV sampling, q table idx
        jpeg_put_bytes(jpeg_buf, (uint8_t [3]) {i + 1, (i == 0 && bpp == 2)? subsampling:0x11, (i > 0)}, 3);

    }

    // Write DHT marker
    jpeg_put_bytes(jpeg_buf, m_dht, sizeof(m_dht));

    // Write DHT-YDC
    jpeg_put_char(jpeg_buf, 0x00);
    jpeg_put_bytes(jpeg_buf, std_dc_luminance_nrcodes + 1, sizeof(std_dc_luminance_nrcodes) - 1);
    jpeg_put_bytes(jpeg_buf, std_dc_luminance_values, sizeof(std_dc_luminance_values));

    // Write DHT-YAC
    jpeg_put_char(jpeg_buf, 0x10);
    jpeg_put_bytes(jpeg_buf, std_ac_luminance_nrcodes + 1, sizeof(std_ac_luminance_nrcodes) - 1);
    jpeg_put_bytes(jpeg_buf, std_ac_luminance_values, sizeof(std_ac_luminance_values));

    if (bpp > 1) {
        // Write DHT-UDC
        jpeg_put_char(jpeg_buf, 0x01);
        jpeg_put_bytes(jpeg_buf, std_dc_chrominance_nrcodes + 1, sizeof(std_dc_chrominance_nrcodes) - 1);
        jpeg_put_bytes(jpeg_buf, std_dc_chrominance_values, sizeof(std_dc_chrominance_values));

        // Write DHT-UAC
        jpeg_put_char(jpeg_buf, 0x11);
        jpeg_put_bytes(jpeg_buf, std_ac_chrominance_nrcodes + 1, sizeof(std_ac_chrominance_nrcodes) - 1);
        jpeg_put_bytes(jpeg_buf, std_ac_chrominance_values, sizeof(std_ac_chrominance_values));
    }

    // Write SOS marker
    jpeg_put_bytes(jpeg_buf, m_sos, sizeof(m_sos));
    for (int i = 0; i < nr_comp; i++) {
        jpeg_put_bytes(jpeg_buf, (uint8_t [2]) {i + 1, (i == 0)? 0x00:0x11}, 2);
    }

    // Spectral selection
    jpeg_put_bytes(jpeg_buf, (uint8_t [3]) {0x00, 0x3F, 0x0}, 3);
}

bool jpeg_compress(image_t *src, image_t *dst, int quality, bool realloc, jpeg_subsampling_t subsampling) {
    OMV_PROFILE_START(__FUNCTION__);

    if (!dst->data) {
        uint32_t size = 0;
        dst->data = fb_alloc_all(&size, FB_ALLOC_PREFER_SIZE | FB_ALLOC_CACHE_ALIGN);
        dst->size = IMLIB_IMAGE_MAX_SIZE(size);
    }

    if (src->is_compressed) {
        return true;
    }

    // JPEG buffer
    jpeg_buf_t jpeg_buf = {
        .idx = 0,
        .buf = dst->pixels,
        .length = dst->size,
        .bitc = 0,
        .bitb = 0,
        .realloc = realloc,
        .overflow = false,
    };

    // Initialize quantization tables
    jpeg_init(quality);

    if (src->is_color) {
        if (subsampling == JPEG_SUBSAMPLING_AUTO) {
            subsampling = JPEG_SUBSAMPLING_420;
        }
    } else {
        subsampling = JPEG_SUBSAMPLING_444;
    }

    jpeg_write_headers(&jpeg_buf, src->w, src->h, src->is_color ? 2 : 1, subsampling);

    int DCY = 0, DCU = 0, DCV = 0;

    switch (subsampling) {
        // Quiet GCC compiler warning (this is never reached)
        case JPEG_SUBSAMPLING_AUTO: {
            break;
        }
        case JPEG_SUBSAMPLING_444: {
            int8_t YDU[JPEG_444_GS_MCU_SIZE];
            int8_t UDU[JPEG_444_GS_MCU_SIZE];
            int8_t VDU[JPEG_444_GS_MCU_SIZE];

            for (int y_offset = 0; y_offset < src->h; y_offset += JPEG_MCU_H) {
                int dy = IM_MIN(JPEG_MCU_H, src->h - y_offset);

                for (int x_offset = 0; x_offset < src->w; x_offset += JPEG_MCU_W) {
                    int dx = IM_MIN(JPEG_MCU_W, src->w - x_offset);

                    jpeg_get_mcu(src, x_offset, y_offset, dx, dy, YDU, UDU, VDU);
                    DCY = jpeg_processDU(&jpeg_buf, YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);

                    if (src->is_color) {
                        DCU = jpeg_processDU(&jpeg_buf, UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                        DCV = jpeg_processDU(&jpeg_buf, VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
                    }
                }

                if (jpeg_buf.overflow) {
                    return true;
                }
            }
            break;
        }
        case JPEG_SUBSAMPLING_422: {
            // color only
            int8_t YDU[JPEG_444_GS_MCU_SIZE * 2];
            int8_t UDU[JPEG_444_GS_MCU_SIZE * 2];
            int8_t VDU[JPEG_444_GS_MCU_SIZE * 2];
            int8_t UDU_avg[JPEG_444_GS_MCU_SIZE];
            int8_t VDU_avg[JPEG_444_GS_MCU_SIZE];

            for (int y_offset = 0; y_offset < src->h; y_offset += JPEG_MCU_H) {
                int dy = IM_MIN(JPEG_MCU_H, src->h - y_offset);

                for (int x_offset = 0; x_offset < src->w; ) {
                    for (int i = 0; i < (JPEG_444_GS_MCU_SIZE * 2);
                         i += JPEG_444_GS_MCU_SIZE, x_offset += JPEG_MCU_W) {
                        int dx = IM_MIN(JPEG_MCU_W, src->w - x_offset);

                        if (dx > 0) {
                            jpeg_get_mcu(src, x_offset, y_offset, dx, dy, YDU + i, UDU + i, VDU + i);
                        } else {
                            memset(YDU + i, 0, JPEG_444_GS_MCU_SIZE);
                            memset(UDU + i, 0, JPEG_444_GS_MCU_SIZE);
                            memset(VDU + i, 0, JPEG_444_GS_MCU_SIZE);
                        }

                        DCY = jpeg_processDU(&jpeg_buf, YDU + i, fdtbl_Y, DCY, YDC_HT, YAC_HT);
                    }

                    // horizontal subsampling of U & V
                    #if defined(ARM_MATH_DSP)
                    uint32_t *UDUp0 = (uint32_t *) UDU;
                    uint32_t *VDUp0 = (uint32_t *) VDU;
                    uint32_t *UDUp1 = (uint32_t *) (UDU + JPEG_444_GS_MCU_SIZE);
                    uint32_t *VDUp1 = (uint32_t *) (VDU + JPEG_444_GS_MCU_SIZE);
                    #else
                    int8_t *UDUp0 = UDU;
                    int8_t *VDUp0 = VDU;
                    int8_t *UDUp1 = UDUp0 + JPEG_444_GS_MCU_SIZE;
                    int8_t *VDUp1 = VDUp0 + JPEG_444_GS_MCU_SIZE;
                    #endif
                    for (int j = 0; j < JPEG_444_GS_MCU_SIZE; j += JPEG_MCU_W) {
                        #if defined(ARM_MATH_DSP)
                        uint32_t UDUp0_3210 = *UDUp0++;
                        uint32_t UDUp0_avg_32_10 = __SHADD8(UDUp0_3210, __UXTB16_RORn(UDUp0_3210, 8));
                        UDU_avg[j] = UDUp0_avg_32_10;
                        UDU_avg[j + 1] = UDUp0_avg_32_10 >> 16;

                        uint32_t UDUp0_7654 = *UDUp0++;
                        uint32_t UDUp0_avg_76_54 = __SHADD8(UDUp0_7654, __UXTB16_RORn(UDUp0_7654, 8));
                        UDU_avg[j + 2] = UDUp0_avg_76_54;
                        UDU_avg[j + 3] = UDUp0_avg_76_54 >> 16;

                        uint32_t UDUp1_3210 = *UDUp1++;
                        uint32_t UDUp1_avg_32_10 = __SHADD8(UDUp1_3210, __UXTB16_RORn(UDUp1_3210, 8));
                        UDU_avg[j + 4] = UDUp1_avg_32_10;
                        UDU_avg[j + 5] = UDUp1_avg_32_10 >> 16;

                        uint32_t UDUp1_7654 = *UDUp1++;
                        uint32_t UDUp1_avg_76_54 = __SHADD8(UDUp1_7654, __UXTB16_RORn(UDUp1_7654, 8));
                        UDU_avg[j + 6] = UDUp1_avg_76_54;
                        UDU_avg[j + 7] = UDUp1_avg_76_54 >> 16;

                        uint32_t VDUp0_3210 = *VDUp0++;
                        uint32_t VDUp0_avg_32_10 = __SHADD8(VDUp0_3210, __UXTB16_RORn(VDUp0_3210, 8));
                        VDU_avg[j] = VDUp0_avg_32_10;
                        VDU_avg[j + 1] = VDUp0_avg_32_10 >> 16;

                        uint32_t VDUp0_7654 = *VDUp0++;
                        uint32_t VDUp0_avg_76_54 = __SHADD8(VDUp0_7654, __UXTB16_RORn(VDUp0_7654, 8));
                        VDU_avg[j + 2] = VDUp0_avg_76_54;
                        VDU_avg[j + 3] = VDUp0_avg_76_54 >> 16;

                        uint32_t VDUp1_3210 = *VDUp1++;
                        uint32_t VDUp1_avg_32_10 = __SHADD8(VDUp1_3210, __UXTB16_RORn(VDUp1_3210, 8));
                        VDU_avg[j + 4] = VDUp1_avg_32_10;
                        VDU_avg[j + 5] = VDUp1_avg_32_10 >> 16;

                        uint32_t VDUp1_7654 = *VDUp1++;
                        uint32_t VDUp1_avg_76_54 = __SHADD8(VDUp1_7654, __UXTB16_RORn(VDUp1_7654, 8));
                        VDU_avg[j + 6] = VDUp1_avg_76_54;
                        VDU_avg[j + 7] = VDUp1_avg_76_54 >> 16;
                        #else
                        for (int i = 0; i < JPEG_MCU_W; i += 2) {
                            UDU_avg[j + (i / 2)] = (UDUp0[i] + UDUp0[i + 1]) / 2;
                            VDU_avg[j + (i / 2)] = (VDUp0[i] + VDUp0[i + 1]) / 2;
                            UDU_avg[j + (i / 2) + (JPEG_MCU_W / 2)] = (UDUp1[i] + UDUp1[i + 1]) / 2;
                            VDU_avg[j + (i / 2) + (JPEG_MCU_W / 2)] = (VDUp1[i] + VDUp1[i + 1]) / 2;
                        }
                        UDUp0 += JPEG_MCU_W;
                        VDUp0 += JPEG_MCU_W;
                        UDUp1 += JPEG_MCU_W;
                        VDUp1 += JPEG_MCU_W;
                        #endif
                    }

                    DCU = jpeg_processDU(&jpeg_buf, UDU_avg, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                    DCV = jpeg_processDU(&jpeg_buf, VDU_avg, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
                }

                if (jpeg_buf.overflow) {
                    return true;
                }
            }
            break;
        }
        case JPEG_SUBSAMPLING_420: {
            // color only
            int8_t YDU[JPEG_444_GS_MCU_SIZE * 4];
            int8_t UDU[JPEG_444_GS_MCU_SIZE * 4];
            int8_t VDU[JPEG_444_GS_MCU_SIZE * 4];
            int8_t UDU_avg[JPEG_444_GS_MCU_SIZE];
            int8_t VDU_avg[JPEG_444_GS_MCU_SIZE];

            for (int y_offset = 0; y_offset < src->h; ) {
                for (int x_offset = 0; x_offset < src->w; ) {
                    for (int j = 0; j < (JPEG_444_GS_MCU_SIZE * 4);
                         j += (JPEG_444_GS_MCU_SIZE * 2), y_offset += JPEG_MCU_H) {
                        int dy = IM_MIN(JPEG_MCU_H, src->h - y_offset);

                        for (int i = 0; i < (JPEG_444_GS_MCU_SIZE * 2);
                             i += JPEG_444_GS_MCU_SIZE, x_offset += JPEG_MCU_W) {
                            int dx = IM_MIN(JPEG_MCU_W, src->w - x_offset);

                            if ((dx > 0) && (dy > 0)) {
                                jpeg_get_mcu(src, x_offset, y_offset, dx, dy, YDU + i + j, UDU + i + j, VDU + i + j);
                            } else {
                                memset(YDU + i + j, 0, JPEG_444_GS_MCU_SIZE);
                                memset(UDU + i + j, 0, JPEG_444_GS_MCU_SIZE);
                                memset(VDU + i + j, 0, JPEG_444_GS_MCU_SIZE);
                            }

                            DCY = jpeg_processDU(&jpeg_buf, YDU + i + j, fdtbl_Y, DCY, YDC_HT, YAC_HT);
                        }

                        // Reset back two columns.
                        x_offset -= (JPEG_MCU_W * 2);
                    }

                    // Advance to the next columns.
                    x_offset += (JPEG_MCU_W * 2);

                    // Reset back two rows.
                    y_offset -= (JPEG_MCU_H * 2);

                    // horizontal and vertical subsampling of U & V
                    #if defined(ARM_MATH_DSP)
                    uint32_t *UDUp = (uint32_t *) UDU;
                    uint32_t *VDUp = (uint32_t *) VDU;
                    #else
                    int8_t *UDUp0 = UDU;
                    int8_t *VDUp0 = VDU;
                    int8_t *UDUp1 = UDUp0 + JPEG_444_GS_MCU_SIZE;
                    int8_t *VDUp1 = VDUp0 + JPEG_444_GS_MCU_SIZE;
                    int8_t *UDUp2 = UDUp1 + JPEG_444_GS_MCU_SIZE;
                    int8_t *VDUp2 = VDUp1 + JPEG_444_GS_MCU_SIZE;
                    int8_t *UDUp3 = UDUp2 + JPEG_444_GS_MCU_SIZE;
                    int8_t *VDUp3 = VDUp2 + JPEG_444_GS_MCU_SIZE;
                    #endif
                    for (int j = 0, k = JPEG_444_GS_MCU_SIZE / 2; k < JPEG_444_GS_MCU_SIZE;
                         j += JPEG_MCU_W, k += JPEG_MCU_W) {
                        #if defined(ARM_MATH_DSP)
                        for (int i = 0; i < 4; i++) {
                            int index = ((i & 2) ? k : j) + ((i & 1) * 4);

                            uint32_t UDU_r0_3210 = UDUp[i * 16];
                            uint32_t UDU_r0_avg_32_10 = __SHADD8(UDU_r0_3210, __UXTB16_RORn(UDU_r0_3210, 8));
                            uint32_t UDU_r0_7654 = UDUp[(i * 16) + 1];
                            uint32_t UDU_r0_avg_76_54 = __SHADD8(UDU_r0_7654, __UXTB16_RORn(UDU_r0_7654, 8));

                            uint32_t UDU_r1_3210 = UDUp[(i * 16) + 2];
                            uint32_t UDU_r1_avg_32_10 = __SHADD8(UDU_r1_3210, __UXTB16_RORn(UDU_r1_3210, 8));
                            uint32_t UDU_r1_7654 = UDUp[(i * 16) + 3];
                            uint32_t UDU_r1_avg_76_54 = __SHADD8(UDU_r1_7654, __UXTB16_RORn(UDU_r1_7654, 8));

                            uint32_t UDU_r0_r1_avg_32_10 = __SHADD8(UDU_r0_avg_32_10, UDU_r1_avg_32_10);
                            UDU_avg[index] = UDU_r0_r1_avg_32_10;
                            UDU_avg[index + 1] = UDU_r0_r1_avg_32_10 >> 16;

                            uint32_t UDU_r0_r1_avg_76_54 = __SHADD8(UDU_r0_avg_76_54, UDU_r1_avg_76_54);
                            UDU_avg[index + 2] = UDU_r0_r1_avg_76_54;
                            UDU_avg[index + 3] = UDU_r0_r1_avg_76_54 >> 16;

                            uint32_t VDU_r0_3210 = VDUp[i * 16];
                            uint32_t VDU_r0_avg_32_10 = __SHADD8(VDU_r0_3210, __UXTB16_RORn(VDU_r0_3210, 8));
                            uint32_t VDU_r0_7654 = VDUp[(i * 16) + 1];
                            uint32_t VDU_r0_avg_76_54 = __SHADD8(VDU_r0_7654, __UXTB16_RORn(VDU_r0_7654, 8));

                            uint32_t VDU_r1_3210 = VDUp[(i * 16) + 2];
                            uint32_t VDU_r1_avg_32_10 = __SHADD8(VDU_r1_3210, __UXTB16_RORn(VDU_r1_3210, 8));
                            uint32_t VDU_r1_7654 = VDUp[(i * 16) + 3];
                            uint32_t VDU_r1_avg_76_54 = __SHADD8(VDU_r1_7654, __UXTB16_RORn(VDU_r1_7654, 8));

                            uint32_t VDU_r0_r1_avg_32_10 = __SHADD8(VDU_r0_avg_32_10, VDU_r1_avg_32_10);
                            VDU_avg[index] = VDU_r0_r1_avg_32_10;
                            VDU_avg[index + 1] = VDU_r0_r1_avg_32_10 >> 16;

                            uint32_t VDU_r0_r1_avg_76_54 = __SHADD8(VDU_r0_avg_76_54, VDU_r1_avg_76_54);
                            VDU_avg[index + 2] = VDU_r0_r1_avg_76_54;
                            VDU_avg[index + 3] = VDU_r0_r1_avg_76_54 >> 16;
                        }
                        UDUp += 4;
                        VDUp += 4;
                        #else
                        for (int i = 0; i < JPEG_MCU_W; i += 2) {
                            UDU_avg[j + (i / 2)] =
                                (UDUp0[i] + UDUp0[i + 1] + UDUp0[i + JPEG_MCU_W] + UDUp0[i + 1 + JPEG_MCU_W]) / 4;
                            VDU_avg[j + (i / 2)] =
                                (VDUp0[i] + VDUp0[i + 1] + VDUp0[i + JPEG_MCU_W] + VDUp0[i + 1 + JPEG_MCU_W]) / 4;
                            UDU_avg[j + (i / 2) + (JPEG_MCU_W / 2)] =
                                (UDUp1[i] + UDUp1[i + 1] + UDUp1[i + JPEG_MCU_W] + UDUp1[i + 1 + JPEG_MCU_W]) / 4;
                            VDU_avg[j + (i / 2) + (JPEG_MCU_W / 2)] =
                                (VDUp1[i] + VDUp1[i + 1] + VDUp1[i + JPEG_MCU_W] + VDUp1[i + 1 + JPEG_MCU_W]) / 4;
                            UDU_avg[k + (i / 2)] =
                                (UDUp2[i] + UDUp2[i + 1] + UDUp2[i + JPEG_MCU_W] + UDUp2[i + 1 + JPEG_MCU_W]) / 4;
                            VDU_avg[k + (i / 2)] =
                                (VDUp2[i] + VDUp2[i + 1] + VDUp2[i + JPEG_MCU_W] + VDUp2[i + 1 + JPEG_MCU_W]) / 4;
                            UDU_avg[k + (i / 2) + (JPEG_MCU_W / 2)] =
                                (UDUp3[i] + UDUp3[i + 1] + UDUp3[i + JPEG_MCU_W] + UDUp3[i + 1 + JPEG_MCU_W]) / 4;
                            VDU_avg[k + (i / 2) + (JPEG_MCU_W / 2)] =
                                (VDUp3[i] + VDUp3[i + 1] + VDUp3[i + JPEG_MCU_W] + VDUp3[i + 1 + JPEG_MCU_W]) / 4;
                        }
                        UDUp0 += JPEG_MCU_W * 2;
                        VDUp0 += JPEG_MCU_W * 2;
                        UDUp1 += JPEG_MCU_W * 2;
                        VDUp1 += JPEG_MCU_W * 2;
                        UDUp2 += JPEG_MCU_W * 2;
                        VDUp2 += JPEG_MCU_W * 2;
                        UDUp3 += JPEG_MCU_W * 2;
                        VDUp3 += JPEG_MCU_W * 2;
                        #endif
                    }

                    DCU = jpeg_processDU(&jpeg_buf, UDU_avg, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                    DCV = jpeg_processDU(&jpeg_buf, VDU_avg, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
                }

                if (jpeg_buf.overflow) {
                    return true;
                }

                // Advance to the next rows.
                y_offset += (JPEG_MCU_H * 2);
            }
            break;
        }
    }

    // Do the bit alignment of the EOI marker
    jpeg_write_bits(&jpeg_buf, (const uint16_t []) {0x7F, 7});

    // EOI
    jpeg_put_char(&jpeg_buf, 0xFF);
    jpeg_put_char(&jpeg_buf, 0xD9);

    dst->size = jpeg_buf.idx;
    dst->data = jpeg_buf.buf;

    OMV_PROFILE_END(__FUNCTION__);
    return false;
}

#endif // (OMV_JPEG_CODEC_ENABLE == 0)

bool jpeg_is_valid(image_t *img) {
    uint8_t *p = img->data, *p_end = img->data + img->size;
    while (p < p_end) {
        uint16_t header = (p[0] << 8) | p[1];
        p += sizeof(uint16_t);
        if ((0xFFD0 <= header) && (header <= 0xFFD9)) {
            continue;
        } else if (0xFFDA == header) {
            // Start-of-Scan (no more jpeg headers left).
            return true;
        } else if (((0xFFC0 <= header) && (header <= 0xFFCF))
                   || ((0xFFDB <= header) && (header <= 0xFFDF))
                   || ((0xFFE0 <= header) && (header <= 0xFFEF))
                   || ((0xFFF0 <= header) && (header <= 0xFFFE))) {
            uint16_t size = (p[0] << 8) | p[1];
            p += sizeof(uint16_t);
            if (((0xFFC1 <= header) && (header <= 0xFFC3))
                || ((0xFFC5 <= header) && (header <= 0xFFC7))
                || ((0xFFC9 <= header) && (header <= 0xFFCB))
                || ((0xFFCD <= header) && (header <= 0xFFCF))) {
                // Non-baseline jpeg.
                return false;
            } else {
                p += size - sizeof(uint16_t);
            }
        } else {
            // Invalid JPEG
            return false;
        }
    }
    return false;
}

int jpeg_clean_trailing_bytes(int size, uint8_t *data) {
    while ((size > 1) && ((data[size - 2] != 0xFF) || (data[size - 1] != 0xD9))) {
        size -= 1;
    }

    return size;
}

#if defined(IMLIB_ENABLE_IMAGE_FILE_IO)
// This function inits the geometry values of an image.
void jpeg_read_geometry(FIL *fp, image_t *img, const char *path, jpg_read_settings_t *rs) {
    for (;;) {
        uint16_t header;
        file_read(fp, &header, 2);
        header = __REV16(header);
        if ((0xFFD0 <= header) && (header <= 0xFFD9)) {
            continue;
        } else if (((0xFFC0 <= header) && (header <= 0xFFCF))
                   || ((0xFFDA <= header) && (header <= 0xFFDF))
                   || ((0xFFE0 <= header) && (header <= 0xFFEF))
                   || ((0xFFF0 <= header) && (header <= 0xFFFE))) {
            uint16_t size;
            file_read(fp, &size, 2);
            size = __REV16(size);
            if (((0xFFC0 <= header) && (header <= 0xFFC3))
                || ((0xFFC5 <= header) && (header <= 0xFFC7))
                || ((0xFFC9 <= header) && (header <= 0xFFCB))
                || ((0xFFCD <= header) && (header <= 0xFFCF))) {
                file_read(fp, NULL, 1);
                uint16_t height;
                file_read(fp, &height, 2);
                height = __REV16(height);

                uint16_t width;
                file_read(fp, &width, 2);
                width = __REV16(width);

                rs->jpg_w = width;
                rs->jpg_h = height;
                rs->jpg_size = IMLIB_IMAGE_MAX_SIZE(f_size(fp));

                img->w = rs->jpg_w;
                img->h = rs->jpg_h;
                img->size = rs->jpg_size;
                img->pixfmt = PIXFORMAT_JPEG;
                return;
            } else {
                file_seek(fp, f_tell(fp) + size - 2);
            }
        } else {
            file_raise_corrupted(fp);
        }
    }
}

// This function reads the pixel values of an image.
void jpeg_read_pixels(FIL *fp, image_t *img) {
    file_seek(fp, 0);
    file_read(fp, img->pixels, img->size);
}

void jpeg_read(image_t *img, const char *path) {
    FIL fp;
    jpg_read_settings_t rs;

    // Do not use file buffering here.
    file_open(&fp, path, false, FA_READ | FA_OPEN_EXISTING);
    jpeg_read_geometry(&fp, img, path, &rs);

    if (!img->pixels) {
        image_xalloc(img, img->size);
    }

    jpeg_read_pixels(&fp, img);
    file_close(&fp);
}

void jpeg_write(image_t *img, const char *path, int quality) {
    FIL fp;
    file_open(&fp, path, false, FA_WRITE | FA_CREATE_ALWAYS);
    if (IM_IS_JPEG(img)) {
        file_write(&fp, img->pixels, img->size);
    } else {
        // alloc in jpeg compress
        image_t out = { .w = img->w, .h = img->h, .pixfmt = PIXFORMAT_JPEG, .size = 0, .pixels = NULL };
        // When jpeg_compress needs more memory than in currently allocated it
        // will try to realloc. MP will detect that the pointer is outside of
        // the heap and return NULL which will cause an out of memory error.
        jpeg_compress(img, &out, quality, false, JPEG_SUBSAMPLING_AUTO);
        file_write(&fp, out.pixels, out.size);
        fb_free(); // frees alloc in jpeg_compress()
    }
    file_close(&fp);
}
#endif //IMLIB_ENABLE_IMAGE_FILE_IO)
